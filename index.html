<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Polygon Fun">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#667eea">
    <meta name="description" content="Slice polygons into target pieces in this fun geometry puzzle game.">
    <!-- Manifest is injected only on http/https to avoid file:// CORS/origin=null errors -->
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-32x32.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192x192.png">
    <title>Polygon Fun</title>
    <!-- Sci-Fi "Syncopate" Font for the Shattered Prism Title -->
    <link href="https://fonts.googleapis.com/css2?family=Syncopate:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* CSS Custom Properties for Responsive Design System */
        :root {
            /* Base font size - scales with viewport */
            --base-font-size: clamp(12px, 1.5vw, 16px);
            --font-scale: 1;

            /* Spacing system - relative units */
            --spacing-xs: clamp(4px, 0.5vw, 6px);
            --spacing-sm: clamp(6px, 0.75vw, 8px);
            --spacing-md: clamp(8px, 1vw, 12px);
            --spacing-lg: clamp(12px, 1.5vw, 16px);
            --spacing-xl: clamp(16px, 2vw, 24px);
            --spacing-2xl: clamp(20px, 2.5vw, 32px);

            /* Touch target sizes - minimum 44px for accessibility */
            --touch-target-min: 44px;
            --touch-target-sm: clamp(36px, 4.5vw, 44px);
            --touch-target-md: clamp(44px, 5.5vw, 56px);
            --touch-target-lg: clamp(48px, 6vw, 64px);

            /* Sidebar widths - responsive */
            --sidebar-width-mobile: 0;
            --sidebar-width-tablet: clamp(200px, 25vw, 280px);
            --sidebar-width-desktop: clamp(240px, 20vw, 320px);

            /* Border radius - scales with size */
            --radius-sm: clamp(4px, 0.5vw, 6px);
            --radius-md: clamp(6px, 0.75vw, 8px);
            --radius-lg: clamp(8px, 1vw, 12px);
            --radius-xl: clamp(12px, 1.5vw, 16px);

            /* Colors */
            --color-primary: #667eea;
            --color-primary-dark: #764ba2;
            --color-bg: rgba(255, 255, 255, 0.95);
            --color-border: #e0e0e0;

            /* Z-index layers */
            --z-toolbar: 1000;
            --z-menu: 1100;
            --z-overlay: 2000;

            /* Device type flags (set by JS) */
            --is-mobile: 0;
            --is-tablet: 0;
            --is-desktop: 1;
            --is-touch: 0;
            --is-portrait: 0;
            --is-landscape: 1;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: var(--base-font-size);
            -webkit-text-size-adjust: 100%;
            -moz-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            display: flex;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            /* Dynamic viewport height for mobile */
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-size: var(--base-font-size);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
            /* Prevent double-tap zoom on buttons */
        }

        /* Main Layout - Fully Responsive */
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            /* Critical: Disables browser handling of gestures */
        }

        /* Professional slice mode cursor styling */
        #gameCanvas.slice-mode {
            cursor: crosshair;
        }

        #gameCanvas.slice-active {
            cursor: crosshair;
        }

        .app-container {
            display: flex;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            max-width: 100%;
            max-height: none;
            background: white;
            /* White background to match toolbar areas */
            border-radius: 0;
            margin: 0;
            overflow: hidden;
            box-shadow: none;
            flex-direction: row;
            position: relative;
        }

        /* Main Body Row - Ensure white background in top area */
        .main-body-row {
            background: white;
            /* White background to prevent gray sections above sidebars */
        }

        /* Mobile: Stack vertically */
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
                height: 100vh;
                height: 100dvh;
                margin: 0;
            }
        }

        /* Landscape mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .app-container {
                height: 100vh;
                height: 100dvh;
                margin: 0;
            }
        }

        /* Tablet adjustments */
        @media (min-width: 769px) and (max-width: 1024px) {
            .app-container {
                margin: 0;
            }
        }

        /* Panel Resizing - Responsive */
        .resizable-panel {
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
            flex-shrink: 0;
        }

        .resizable-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            -webkit-overflow-scrolling: touch;
        }

        /* Divider - Touch-friendly on mobile */
        .panel-divider {
            height: clamp(8px, 1vw, 12px);
            min-height: var(--touch-target-sm);
            background: var(--color-border);
            cursor: row-resize;
            position: relative;
            transition: background 0.2s;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            flex-shrink: 0;
        }

        /* Mobile: Larger touch target for divider */
        @media (max-width: 768px) {
            .panel-divider {
                min-height: var(--touch-target-min);
            }
        }

        .panel-divider:hover {
            background: #94a3b8;
        }

        .panel-divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 2px;
            background: #94a3b8;
            border-radius: 1px;
        }

        /* Panel Header with Drag Handle - Responsive */
        .panel-header {
            padding: var(--spacing-md) var(--spacing-lg);
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            font-weight: 600;
            font-size: clamp(13px, 1.75vw, 16px);
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: var(--touch-target-min);
            flex-shrink: 0;
            position: relative;
        }

        /* Panel header layout with back button */
        .panel-header {
            position: relative;
        }

        .panel-header .panel-back-btn {
            position: absolute;
            left: var(--spacing-md);
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
        }

        /* Adjust header content when back button exists */
        .panel-header .panel-back-btn+span,
        .panel-header .panel-back-btn~span {
            margin-left: 60px;
            /* Offset for back button on left */
        }

        .panel-header.dragging {
            opacity: 0.7;
            background: linear-gradient(135deg, #4a6de5 0%, #5a52a3 100%);
        }

        .panel-header.dragging .drag-handle {
            color: white;
        }

        /* Back Button for Mobile Panels */
        .panel-back-btn {
            display: none;
            /* Hidden on desktop */
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s ease;
            align-items: center;
            justify-content: center;
            min-height: var(--touch-target-min);
            min-width: var(--touch-target-min);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Show back button on mobile/tablet and style it */
        @media (max-width: 1024px) {
            .panel-back-btn {
                display: flex;
            }
        }

        .panel-back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateX(-2px);
        }

        .panel-back-btn:active {
            transform: translateX(-2px) scale(0.95);
        }

        .panel-back-btn svg {
            width: 18px;
            height: 18px;
            stroke-width: 2.5;
        }

        /* Back button visibility is handled above */

        /* Toolbar - Compact Top Bar for All Devices */
        .toolbar {
            position: fixed;
            top: clamp(56px, 7vw, 66px);
            /* Pushed down by top tools bar with additional gap */
            left: 0;
            right: 0;
            width: 100%;
            background: white;
            border-bottom: 1px solid var(--color-border);
            padding: clamp(8px, 1.5vw, 12px);
            /* Increased padding */
            display: flex;
            gap: clamp(8px, 2vw, 12px);
            /* Increased gap significantly */
            z-index: var(--z-toolbar);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            align-items: center;
            justify-content: center;
            flex-wrap: nowrap;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
            min-height: clamp(48px, 6vw, 56px);
            /* Increased height */
            max-height: clamp(60px, 8vw, 70px);
            box-sizing: border-box;
        }

        /* Ensure toolbar buttons fit on small screens */
        @media (max-width: 320px) {
            .toolbar {
                padding: 8px;
                gap: 6px;
            }

            .tool-btn {
                width: 36px;
                min-width: 36px;
                height: 36px;
                min-height: 36px;
                font-size: 16px;
            }
        }

        .toolbar::-webkit-scrollbar {
            height: 4px;
        }

        .toolbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .toolbar::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }

        .toolbar::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        .tool-btn {
            width: clamp(40px, 5vw, 48px);
            /* Larger touch target */
            min-width: clamp(40px, 5vw, 48px);
            height: clamp(40px, 5vw, 48px);
            min-height: clamp(40px, 5vw, 48px);
            border: none;
            background: #f0f0f0;
            border-radius: var(--radius-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(18px, 2.5vw, 22px);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            flex-shrink: 0;
            touch-action: manipulation;
            padding: 0;
            margin: 0;
        }

        .tool-btn.combine-btn,
        .tool-btn.split-btn {
            width: auto;
            padding: 0 16px;
            font-size: 14px;
            font-weight: 600;
        }

        .tool-btn:hover {
            background: #e0e0e0;
            transform: scale(1.05);
        }

        .tool-btn:active {
            transform: scale(0.95);
        }

        .tool-btn.active {
            background: var(--color-primary);
            color: white;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .tool-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            font-size: clamp(10px, 1.25vw, 12px);
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: calc(var(--z-toolbar) + 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .tool-btn:hover::after {
            opacity: 1;
        }

        /* Mobile: Smaller tooltips */
        @media (max-width: 768px) {
            .tool-btn::after {
                display: none;
                /* Hide tooltips on mobile to save space */
            }
        }

        /* Sidebar Panels - Responsive Widths */
        .sidebar {
            width: var(--sidebar-width-desktop);
            min-width: 0;
            max-width: 100%;
            background: white;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--color-border);
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            flex-shrink: 0;
            transition: transform 0.3s ease, width 0.3s ease, position 0.3s ease;
            /* Ensure sidebars are visible by default */
            visibility: visible;
            opacity: 1;
        }

        .sidebar-right {
            border-right: none;
            border-left: 1px solid var(--color-border);
        }

        /* Mobile: Sidebars become overlays */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                /* Start below toolbar - top tools bar + toolbar height */
                top: clamp(96px, 12vw, 126px);
                left: 0;
                width: min(85vw, 320px);
                /* Height adjusted to account for top offset */
                height: calc(100vh - clamp(96px, 12vw, 126px));
                height: calc(100dvh - clamp(96px, 12vw, 126px));
                z-index: var(--z-menu);
                transform: translateX(-100%);
                box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
            }

            .sidebar.sidebar-right {
                left: auto;
                right: 0;
                transform: translateX(100%);
                border-left: none;
                border-right: 1px solid var(--color-border);
            }

            .sidebar.mobile-open {
                transform: translateX(0);
            }

            .sidebar-right.mobile-open {
                transform: translateX(0);
            }
        }

        /* Tablet: Sidebars visible by default (like desktop), but can be toggled to overlay */
        @media (min-width: 769px) and (max-width: 1024px) {
            .sidebar {
                /* On tablets, sidebars are visible by default like desktop */
                width: var(--sidebar-width-tablet);
                position: relative !important;
                transform: none !important;
                box-shadow: none;
                /* Push sidebars down below toolbar - top-tools-bar + toolbar height */
                /* Top tools bar: clamp(48px, 6vw, 56px) + Toolbar: clamp(48px, 6vw, 56px) to clamp(60px, 8vw, 70px) */
                margin-top: clamp(96px, 12vw, 126px);
                /* Constrain height to fill remaining viewport below toolbar */
                height: calc(100vh - clamp(96px, 12vw, 126px));
                height: calc(100dvh - clamp(96px, 12vw, 126px));
                max-height: calc(100vh - clamp(96px, 12vw, 126px));
                max-height: calc(100dvh - clamp(96px, 12vw, 126px));
                top: auto;
                left: auto;
                right: auto;
                z-index: auto;
                /* Ensure visibility */
                visibility: visible !important;
                opacity: 1 !important;
                display: flex !important;
                /* Align to start of flex container */
                align-self: flex-start;
            }

            /* When toggled to overlay mode on tablet (mobile-open class) */
            .sidebar.mobile-open {
                position: fixed !important;
                top: clamp(96px, 12vw, 126px) !important;
                left: 0;
                width: min(70vw, 400px);
                height: calc(100vh - clamp(96px, 12vw, 126px));
                height: calc(100dvh - clamp(96px, 12vw, 126px));
                z-index: var(--z-menu);
                transform: translateX(0) !important;
                box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
                /* Reset margin when in overlay mode */
                margin-top: 0 !important;
                align-self: auto;
            }

            .sidebar.sidebar-right.mobile-open {
                left: auto;
                right: 0;
                transform: translateX(0) !important;
                border-left: none;
                border-right: 1px solid var(--color-border);
                /* Reset margin when in overlay mode */
                margin-top: 0 !important;
                align-self: auto;
            }
        }

        .panel {
            border-bottom: 1px solid #e0e0e0;
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 12px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            /* For Safari compatibility */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-content {
            padding: var(--spacing-md);
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            min-height: 0;
            -webkit-overflow-scrolling: touch;
        }

        /* Canvas Area - Fully Responsive */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #fafafa;
            min-width: 0;
            min-height: 0;
            width: 100%;
            height: 100%;
        }

        /* Mobile: Canvas takes full height minus toolbar */
        @media (max-width: 768px) {
            .canvas-container {
                flex: 1 1 auto;
                min-height: 0;
                order: -1;
                /* Canvas appears first on mobile */
            }
        }

        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            touch-action: none;
            /* Prevent default touch behaviors */
        }

        /* Viewport Controls - moved to lines 1648+ */

        /* Fullscreen button in top tools bar */
        .fullscreen-top-btn {
            background: white;
            border: 1px solid var(--color-border);
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            min-width: 44px;
            height: 36px;
            color: #4a5568;
        }

        .fullscreen-top-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            background: #f7fafc;
            border-color: var(--color-primary);
        }

        .fullscreen-top-btn:active {
            transform: translateY(0);
        }

        .fullscreen-top-btn.active {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            border-color: var(--color-primary);
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .fullscreen-top-btn.active:hover {
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        /* Fullscreen styles */
        :fullscreen,
        :-webkit-full-screen,
        :-moz-full-screen,
        :-ms-fullscreen {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        body:fullscreen,
        body:-webkit-full-screen,
        body:-moz-full-screen,
        body:-ms-fullscreen {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .fullscreen-active .canvas-container {
            height: 100vh;
            width: 100vw;
        }

        .fullscreen-active .app-container {
            width: 100vw;
            height: 100vh;
        }

        /* Properties Display - Responsive */
        .property-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px;
            font-size: clamp(12px, 1.4vw, 14px);
            gap: 12px;
            min-height: 28px;
            align-items: center;
            border-radius: 4px;
            transition: background-color 0.15s ease;
        }

        .property-row:hover {
            background-color: #f8f9fa;
        }

        .property-label {
            color: #64748b;
            flex-shrink: 0;
            font-weight: 500;
            font-size: clamp(11px, 1.3vw, 13px);
        }

        .property-value {
            font-weight: 600;
            color: #1e293b;
            text-align: right;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: clamp(12px, 1.4vw, 14px);
        }

        /* Layer Item - Responsive */
        .layer-item {
            padding: var(--spacing-md);
            background: #f8f8f8;
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-sm);
            margin-left: var(--spacing-md);
            margin-right: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            cursor: pointer;
            transition: all 0.2s;
            min-height: var(--touch-target-min);
            touch-action: manipulation;
        }

        .layer-item:hover {
            background: #f0f0f0;
        }

        .layer-item.selected {
            background: #e8e0ff;
            border: 1px solid #667eea;
        }

        .layer-color {
            width: clamp(28px, 3.5vw, 32px);
            min-width: clamp(28px, 3.5vw, 32px);
            height: clamp(28px, 3.5vw, 32px);
            min-height: clamp(28px, 3.5vw, 32px);
            border-radius: var(--radius-sm);
            border: clamp(2px, 0.25vw, 3px) solid white;
            box-shadow: 0 clamp(1px, 0.125vw, 2px) clamp(2px, 0.375vw, 3px) rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

        .layer-name {
            flex: 1;
            font-size: clamp(13px, 1.75vw, 16px);
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .layer-actions {
            display: flex;
            gap: 4px;
        }

        .layer-action-btn {
            width: var(--touch-target-sm);
            min-width: var(--touch-target-min);
            height: var(--touch-target-sm);
            min-height: var(--touch-target-min);
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(14px, 1.875vw, 18px);
            transition: background 0.2s;
            touch-action: manipulation;
            flex-shrink: 0;
        }

        .layer-action-btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        /* Visualizer Items - Responsive */
        .viz-item {
            padding: var(--spacing-md);
            background: #f0f9ff;
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-sm);
            margin-left: var(--spacing-md);
            margin-right: var(--spacing-md);
            cursor: pointer;
            transition: all 0.2s;
            border: clamp(2px, 0.25vw, 3px) solid transparent;
            min-height: var(--touch-target-min);
            touch-action: manipulation;
            display: flex;
            align-items: center;
        }

        .viz-item:hover {
            background: #e0f2fe;
            border-color: #0ea5e9;
        }

        .viz-item.active {
            background: #eef2ff;
            border-color: #818cf8;
        }

        .visualizer-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #cbd5e1;
            border-radius: 4px;
            background: white;
            margin-right: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .viz-item:hover .visualizer-checkbox {
            border-color: #0ea5e9;
        }

        .viz-item.active .visualizer-checkbox {
            background: #4f46e5;
            border-color: #4f46e5;
        }

        .viz-item.active .visualizer-checkbox::after {
            content: 'âœ“';
            color: white;
            font-size: 14px;
            font-weight: 800;
        }

        .viz-item-title {
            font-weight: 600;
            color: #0369a1;
            margin-bottom: var(--spacing-xs);
            font-size: clamp(13px, 1.75vw, 16px);
        }

        /* Triangle Classifier - Responsive */
        .triangle-classifier {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 8px 10px;
            border-radius: 6px;
            margin: 0;
            grid-column: 1 / -1;
        }

        .triangle-classifier-title {
            font-weight: 600;
            margin-bottom: 6px;
            font-size: clamp(11px, 1.3vw, 13px);
            opacity: 0.95;
        }

        .classifier-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.25);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: clamp(10px, 1.2vw, 12px);
            margin-right: 6px;
            margin-top: 2px;
            font-weight: 500;
            backdrop-filter: blur(4px);
        }

        /* Coordinate Display - Responsive */
        .coord-display {
            position: absolute;
            bottom: clamp(12px, 2vw, 20px);
            left: clamp(12px, 2vw, 20px);
            background: white;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-md);
            font-size: clamp(11px, 1.5vw, 14px);
            font-family: monospace;
            box-shadow: 0 clamp(2px, 0.5vw, 4px) clamp(6px, 1vw, 8px) rgba(0, 0, 0, 0.1);
            z-index: calc(var(--z-toolbar) - 1);
            max-width: calc(100% - var(--spacing-2xl));
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Mobile: Adjust position */
        @media (max-width: 768px) {
            .coord-display {
                bottom: clamp(80px, 12vw, 100px);
                left: var(--spacing-md);
                max-width: calc(100% - clamp(120px, 20vw, 160px));
            }
        }

        /* Color Picker - Responsive */
        .color-picker {
            display: flex;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
            margin-top: var(--spacing-md);
            padding: 0 var(--spacing-md);
        }

        .color-option {
            width: clamp(32px, 4vw, 40px);
            min-width: clamp(32px, 4vw, 40px);
            height: clamp(32px, 4vw, 40px);
            min-height: clamp(32px, 4vw, 40px);
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: clamp(2px, 0.25vw, 3px) solid transparent;
            transition: all 0.2s;
            touch-action: manipulation;
            flex-shrink: 0;
        }

        .color-option:hover {
            transform: scale(1.1);
            border-color: #333;
        }

        .color-option.selected {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        /* Create New Polygon Button & Menu - Responsive */
        .create-polygon-container {
            position: relative;
            margin-bottom: var(--spacing-lg);
            padding: 0 var(--spacing-md);
        }

        .create-polygon-btn {
            width: 100%;
            padding: var(--spacing-md) var(--spacing-lg);
            min-height: var(--touch-target-min);
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-size: clamp(13px, 1.75vw, 16px);
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            touch-action: manipulation;
        }

        .create-polygon-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #7c8ff0 0%, #8659af 100%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .create-polygon-btn:hover::before {
            opacity: 1;
        }

        .create-polygon-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .create-polygon-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }

        .create-polygon-btn:focus-visible {
            outline: 3px solid #667eea;
            outline-offset: 2px;
        }

        .create-polygon-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .create-polygon-btn .btn-icon,
        .create-polygon-btn .btn-chevron {
            position: relative;
            z-index: 1;
        }

        .create-polygon-btn .btn-icon {
            flex-shrink: 0;
        }

        .create-polygon-btn span {
            position: relative;
            z-index: 1;
            flex: 1;
            text-align: left;
        }

        /* Shape Selection Grid - Modal */
        .shape-option-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 16px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .shape-option-card:hover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
        }

        .shape-option-card:active {
            transform: translateY(0);
        }

        .shape-option-card .shape-icon {
            width: 48px;
            height: 48px;
            font-size: 24px;
            margin-bottom: 12px;
            background: #eef2ff;
            color: #4f46e5;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-md);
        }

        .shape-option-card .shape-name {
            font-size: 15px;
            margin-bottom: 4px;
            color: #2d3748;
            font-weight: 600;
        }

        .shape-option-card .shape-hint {
            font-size: 12px;
            color: #718096;
        }

        .shape-shortcut {
            padding: 4px 8px;
            background: #f0f0f0;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: #666;
            font-family: monospace;
        }

        /* Announcement for screen readers */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Flash animation for feedback */
        @keyframes flash {

            0%,
            100% {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }

            50% {
                background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            }
        }



        /* Tutorial Overlay - Responsive */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: var(--z-overlay);
            padding: var(--spacing-lg);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tutorial-modal {
            background: white;
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            max-width: min(90vw, 500px);
            width: 100%;
            max-height: min(90vh, 600px);
            overflow-y: auto;
            animation: slideIn 0.3s ease-out;
            margin: auto;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .tutorial-title {
            font-size: clamp(20px, 3vw, 28px);
            font-weight: 700;
            margin-bottom: var(--spacing-lg);
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tutorial-content {
            font-size: clamp(13px, 1.75vw, 16px);
            line-height: 1.6;
            color: #444;
        }

        .tutorial-actions {
            margin-top: 20px;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .btn {
            padding: var(--spacing-md) var(--spacing-lg);
            min-height: var(--touch-target-min);
            border: none;
            border-radius: var(--radius-md);
            font-size: clamp(13px, 1.75vw, 16px);
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        /* Grid Toggle - Responsive */
        /* Top Tools Bar - Professional Tabs */
        .top-tools-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            height: clamp(48px, 6vw, 56px);
            /* Increased height matches toolbar */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            /* Fixed generous gap */
            background: white;
            padding: 0 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            /* z-index must be higher than toolbar */
            z-index: calc(var(--z-toolbar) + 1);
            box-sizing: border-box;
        }

        .top-tool-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            height: 100%;
            cursor: pointer;
        }

        .top-tool-item:hover {
            background: #f7fafc;
        }

        .top-bar-btn {
            background: white;
            border: 1px solid var(--color-border);
            padding: 8px 16px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            color: #4a5568;
        }

        .top-bar-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            background: #f7fafc;
            color: var(--color-primary);
            border-color: var(--color-primary);
        }

        .top-bar-btn:active {
            transform: translateY(0);
        }

        /* Mobile: Adjust position */
        @media (max-width: 768px) {
            .top-tools-bar {
                top: clamp(10px, 2vw, 15px);
            }
        }

        .toggle-switch {
            width: 36px;
            height: 20px;
            background: #ccc;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(16px);
        }

        /* Drag Handle for Panels */
        .drag-handle {
            cursor: move;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            -webkit-user-select: none;
            user-select: none;
            /* For Safari compatibility */
            padding: 0 4px;
        }

        .drag-handle:hover {
            color: white;
        }

        .panel-header.dragging {
            opacity: 0.7;
            background: linear-gradient(135deg, #4a6de5 0%, #5a52a3 100%);
        }

        .panel.drag-over {
            box-shadow: 0 0 0 2px #667eea;
        }

        .panel {
            transition: box-shadow 0.2s ease;
        }

        /* Resizable Panel Styles */
        .resizable-panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
            /* Important for flex children to shrink */
            overflow: hidden;
            position: relative;
        }

        .resizable-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            position: relative;
            padding: var(--spacing-sm);
        }

        /* Custom scrollbar for panels */
        .resizable-panel-content::-webkit-scrollbar {
            width: clamp(6px, 0.75vw, 8px);
        }

        .resizable-panel-content::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .resizable-panel-content::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: var(--radius-sm);
        }

        .resizable-panel-content::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Mobile and Tablet sidebar backdrop */
        .sidebar-backdrop {
            position: fixed;
            /* Start below toolbar - same as sidebar top */
            top: clamp(96px, 12vw, 126px);
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: calc(var(--z-menu) - 1);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            display: none;
        }

        /* Show backdrop on mobile only (tablets don't need it as sidebars are visible) */
        @media (max-width: 768px) {
            .sidebar-backdrop {
                display: block;
            }
        }

        .sidebar-backdrop.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Ensure text is always readable */
        @media (max-width: 768px) {
            body {
                font-size: clamp(14px, 4vw, 16px);
            }
        }

        /* Prevent text from being too small */
        @media (max-width: 320px) {
            :root {
                --base-font-size: 14px;
            }
        }

        /* Large screen optimizations */
        @media (min-width: 1920px) {
            .app-container {
                max-width: none;
                margin: 0;
            }
        }

        /* High DPI display optimizations */
        @media (-webkit-min-device-pixel-ratio: 2),
        (min-resolution: 192dpi) {

            .tool-btn,
            .zoom-btn,
            .layer-action-btn {
                image-rendering: -webkit-optimize-contrast;
                image-rendering: crisp-edges;
            }
        }

        /* Landscape mobile optimizations */
        @media (max-width: 768px) and (orientation: landscape) {
            .toolbar {
                min-height: clamp(32px, 4vw, 40px);
                max-height: clamp(32px, 4vw, 40px);
                padding: clamp(3px, 0.4vw, 5px) clamp(6px, 0.75vw, 10px);
            }

            .app-container {
                margin-top: clamp(32px, 4vw, 40px);
            }

            .zoom-controls {
                bottom: clamp(50px, 8vw, 70px);
            }

            .coord-display {
                bottom: clamp(50px, 8vw, 70px);
            }
        }

        /* Portrait mobile optimizations */
        @media (max-width: 768px) and (orientation: portrait) {
            .toolbar {
                gap: clamp(2px, 0.25vw, 3px);
                padding: clamp(4px, 0.5vw, 6px) clamp(6px, 0.75vw, 10px);
            }
        }

        /* Ensure all interactive elements are accessible */
        button,
        a,
        [role="button"],
        [tabindex="0"] {
            min-height: var(--touch-target-min);
            min-width: var(--touch-target-min);
        }

        /* Focus states for accessibility */
        *:focus-visible {
            outline: clamp(2px, 0.25vw, 3px) solid var(--color-primary);
            outline-offset: clamp(2px, 0.25vw, 3px);
        }

        /* Smooth transitions for layout changes */
        .app-container,
        .sidebar,
        .canvas-container {
            transition: width 0.3s ease, height 0.3s ease, transform 0.3s ease;
        }

        /* Mobile Menu Toggle Buttons */
        .mobile-menu-toggle {
            position: absolute;
            width: 44px;
            height: 44px;
            z-index: 999;
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        .mobile-menu-toggle:active {
            transform: scale(0.95);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        /* Hide on desktop */
        @media (min-width: 769px) {
            .mobile-menu-toggle {
                display: none !important;
            }
        }

        /* Ensure buttons don't interfere with canvas interactions */
        @media (max-width: 768px) {
            .mobile-menu-toggle {
                pointer-events: auto;
            }

            /* Make sure canvas container allows pointer events through except for buttons */
            #canvasContainer {
                position: relative;
            }
        }

        /* Viewport controls final positioning (top-left below blue buttons) */
        .viewport-controls {
            position: absolute;
            top: clamp(120px, 14vw, 130px);
            left: clamp(12px, 2vw, 20px);
            bottom: auto;
            right: auto;
            display: grid;
            grid-template-columns: repeat(3, 42px);
            grid-template-rows: repeat(2, 42px) auto;
            align-items: center;
            justify-items: center;
            gap: 8px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(203, 213, 225, 0.95);
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.15);
            backdrop-filter: blur(8px);
            z-index: 1000;
        }

        .pan-controls {
            display: contents;
        }

        .pan-btn,
        .zoom-btn {
            width: 42px;
            min-width: 42px;
            height: 42px;
            min-height: 42px;
            border: 1px solid #cbd5e1;
            background: #ffffff;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 700;
            color: #334155;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
        }

        /* removed mobile-menu-toggle css if it was here, but i need to find the html */

        .control-btn-blue {
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            color: white;
            border-color: #2563eb;
            box-shadow: 0 2px 5px rgba(37, 99, 235, 0.3);
        }

        .pan-btn:hover,
        .zoom-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .control-btn-blue:hover {
            box-shadow: 0 4px 10px rgba(37, 99, 235, 0.4);
            filter: brightness(1.05);
        }

        .pan-btn:active,
        .zoom-btn:active {
            transform: scale(0.96);
        }

        .grid-snap-controls {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #e2e8f0;
            width: 100%;
            background: transparent;
            border-radius: 0;
        }

        .grid-snap-controls input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #3b82f6;
            cursor: pointer;
        }

        .grid-snap-controls .grid-snap-label {
            font-size: 14px;
            font-weight: 600;
            color: #334155;
            line-height: 1.2;
        }

        /* Coordinate Display */
        .coord-display {
            position: absolute;
            bottom: clamp(60px, 8vw, 80px);
            /* Pushed up */
            left: clamp(16px, 2vw, 24px);
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: var(--radius-md);
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            z-index: var(--z-canvas-ui);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(4px);
        }

        /* Bottom Properties Panel */
        .bottom-panel {
            width: 100%;
            background: white;
            border-top: 1px solid var(--color-border);
            display: flex;
            flex-direction: column;
            transition: height 0.3s ease;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
            z-index: 1001;
            height: 180px;
            /* Default expanded height */
        }

        .bottom-panel.collapsed {
            height: 40px;
            /* Header height only */
            pointer-events: none;
            position: relative;
        }

        .bottom-panel.collapsed * {
            pointer-events: none;
        }

        .bottom-panel.collapsed .bottom-panel-content {
            display: none;
            pointer-events: none;
        }

        .bottom-panel.collapsed .bottom-panel-header {
            pointer-events: auto !important;
            position: relative;
            z-index: 1002;
        }

        .bottom-panel.collapsed .bottom-panel-header * {
            pointer-events: auto;
        }

        .bottom-panel-header {
            height: 40px;
            padding: 0 16px;
            background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--color-border);
            cursor: pointer;
        }

        .bottom-panel-title {
            font-weight: 600;
            color: #4a5568;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bottom-panel-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            color: #718096;
            transition: transform 0.3s;
        }

        .bottom-panel.collapsed .bottom-panel-toggle {
            transform: rotate(180deg);
        }

        .bottom-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px 12px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 8px;
            align-content: start;
        }

        /* Ensure app container uses column flow */
        .app-container {
            flex-direction: column !important;
        }

        /* Prevent layout shift during resize */
        .canvas-container {
            contain: layout style paint;
        }

        /* Combine Button - Wider for text */
        .tool-btn.combine-btn {
            width: auto;
            min-width: clamp(60px, 8vw, 80px);
            padding: 0 var(--spacing-sm);
            font-weight: 600;
            font-size: clamp(12px, 1.5vw, 14px);
        }

        /* Split Button */
        .tool-btn.split-btn {
            width: auto;
            min-width: clamp(50px, 6vw, 60px);
            padding: 0 var(--spacing-sm);
            font-weight: 600;
            font-size: clamp(12px, 1.5vw, 14px);
        }

        /* Combine Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background: white;
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            max-width: min(90vw, 400px);
            width: 100%;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            font-size: clamp(18px, 2.5vw, 22px);
            font-weight: 700;
            color: var(--color-primary-dark);
            margin-bottom: var(--spacing-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #718096;
            padding: 4px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s;
            line-height: 1;
        }

        .modal-close-btn:hover {
            background: #edf2f7;
            color: #2d3748;
        }

        .modal-body {
            font-size: clamp(14px, 1.75vw, 16px);
            color: #444;
            line-height: 1.5;
            margin-bottom: var(--spacing-lg);
        }

        .modal-footer {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #666;
            cursor: pointer;
        }

        .modal-btn {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            border: none;
            padding: 12px;
            border-radius: var(--radius-md);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .modal-btn:hover {
            opacity: 0.9;
        }

        /* App Dialog (Custom Confirm/Alert) */
        .app-dialog-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.55);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 11000;
            padding: 24px;
            backdrop-filter: blur(6px);
        }

        .app-dialog-panel {
            width: min(92vw, 460px);
            background: white;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 26px 50px rgba(15, 23, 42, 0.35);
            border: 1px solid rgba(226, 232, 240, 0.9);
            animation: modalSlideIn 0.25s ease-out;
        }

        .app-dialog-header {
            padding: 16px 20px;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            font-weight: 700;
            font-size: 18px;
        }

        .app-dialog-close {
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 10px;
            padding: 4px 10px;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .app-dialog-close:hover {
            background: rgba(255, 255, 255, 0.35);
        }

        .app-dialog-body {
            padding: 18px 20px 8px;
            font-size: 15px;
            line-height: 1.6;
            color: #334155;
        }

        .app-dialog-actions {
            padding: 16px 20px 20px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            flex-wrap: wrap;
        }

        .app-dialog-btn {
            border: none;
            border-radius: 12px;
            padding: 10px 18px;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            min-height: 44px;
            transition: transform 0.15s ease, opacity 0.2s ease;
        }

        .app-dialog-btn.primary {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
        }

        .app-dialog-btn.secondary {
            background: #e2e8f0;
            color: #1f2937;
        }

        .app-dialog-btn:hover {
            transform: translateY(-1px);
        }

        .app-dialog-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Main Menu Overlay - AAA Quality */
        #mainMenuOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: transparent;
            /* Canvas will provide background */
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }

        #mainMenuOverlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Fun Game Transition Overlay - Seamless Full-Screen Mask */
        #funTransitionOverlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 999990;
            /* Above EVERYTHING except debug */
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.4s ease-out, visibility 0s linear 0.4s;
        }

        #funTransitionOverlay.active {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
            transition: opacity 0.3s ease-out;
        }

        #funTransitionOverlay.active.exit {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in;
        }

        .fun-game-start-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at top, rgba(102, 126, 234, 0.35), rgba(15, 23, 42, 0.82));
            backdrop-filter: blur(8px);
            z-index: 10001;
            /* Above mainMenuOverlay (9999) */
            padding: 24px;
            /* Mobile touch handling */
            -webkit-overflow-scrolling: touch;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .fun-game-start-overlay[aria-hidden="false"] {
            pointer-events: auto;
        }

        .fun-game-start-panel {
            width: min(92vw, 420px);
            background: white;
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 24px 50px rgba(15, 23, 42, 0.35);
            display: flex;
            flex-direction: column;
            gap: 16px;
            /* Ensure panel receives pointer events */
            pointer-events: auto;
            position: relative;
            z-index: 1;
        }

        .fun-game-start-header {
            padding: 20px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fun-game-start-header h3 {
            margin: 0;
            font-size: 20px;
            font-weight: 800;
        }

        .fun-game-start-close {
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 12px;
            padding: 6px 10px;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.2s ease;
            /* Mobile touch handling */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            pointer-events: auto;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fun-game-start-close:hover {
            background: rgba(255, 255, 255, 0.35);
        }

        .fun-game-start-body {
            padding: 0 24px 12px;
            color: #475569;
            font-size: 15px;
            line-height: 1.5;
        }

        .fun-game-start-meta {
            margin-top: 12px;
            background: #f8fafc;
            border-radius: 12px;
            padding: 10px 12px;
            font-weight: 600;
            color: #1e293b;
            font-size: 13px;
        }

        .fun-game-start-actions {
            padding: 0 24px 24px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .fun-game-start-slots {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .fun-game-start-slot {
            border-radius: 16px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            box-shadow: 0 8px 18px rgba(148, 163, 184, 0.18);
            transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            cursor: pointer;
            /* Mobile touch handling */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            pointer-events: auto;
        }

        .fun-game-start-slot.active {
            border-color: #667eea;
            background: #eef2ff;
            box-shadow: 0 12px 24px rgba(102, 126, 234, 0.25);
        }

        .fun-game-start-slot:hover {
            transform: translateY(-1px);
            box-shadow: 0 14px 26px rgba(100, 116, 139, 0.2);
        }

        .fun-game-start-slot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 700;
            color: #1e293b;
            gap: 8px;
        }

        .fun-game-start-slot-status {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            color: #64748b;
        }

        .fun-game-start-slot-detail {
            font-size: 12px;
            color: #475569;
            line-height: 1.4;
        }

        .fun-game-start-slot-action {
            border: none;
            border-radius: 12px;
            padding: 8px 12px;
            font-weight: 700;
            font-size: 13px;
            cursor: pointer;
            transition: transform 0.15s ease, opacity 0.2s ease;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 40px;
            /* Mobile touch handling */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            pointer-events: auto;
        }

        .fun-game-start-slot-action:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .fun-game-start-actions button {
            border: none;
            border-radius: 14px;
            padding: 12px 18px;
            font-weight: 700;
            font-size: 15px;
            cursor: pointer;
            transition: transform 0.15s ease, opacity 0.2s ease;
            min-height: 48px;
            /* Mobile touch handling */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            pointer-events: auto;
        }

        .fun-game-start-actions button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .fun-game-start-actions button.secondary {
            background: #e2e8f0;
            color: #1f2937;
        }

        .fun-game-start-actions button:hover {
            transform: translateY(-1px);
        }

        .fun-transition-core {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: clamp(20px, 4vw, 32px) clamp(28px, 6vw, 48px);
            border-radius: 24px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 50px rgba(15, 23, 42, 0.35);
            color: white;
            text-align: center;
            min-width: min(80vw, 420px);
            animation: funTransitionFloat 1.6s ease-in-out infinite;
        }

        .fun-transition-title {
            font-size: clamp(20px, 3vw, 28px);
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .fun-transition-subtitle {
            font-size: clamp(13px, 1.8vw, 16px);
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }

        .fun-transition-bar {
            width: min(260px, 70vw);
            height: 6px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 999px;
            overflow: hidden;
        }

        .fun-transition-bar span {
            display: block;
            height: 100%;
            width: 40%;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.95));
            border-radius: 999px;
            animation: funTransitionSweep 1.1s ease-in-out infinite;
        }

        @keyframes funTransitionFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-6px);
            }
        }

        @keyframes funTransitionSweep {
            0% {
                transform: translateX(-120%);
            }

            100% {
                transform: translateX(220%);
            }
        }

        /* THE SHATTERED PRISM TITLE */
        .menu-title-container {
            position: relative;
            margin-bottom: clamp(50px, 6vw, 80px);
            padding: 0 20px;
            perspective: 1000px;
            filter: drop-shadow(0 0 15px rgba(102, 126, 234, 0.5));
        }

        .shattered-text {
            font-family: 'Syncopate', sans-serif;
            font-size: clamp(28px, 6vw, 80px);
            /* Reduced min size for mobile */
            font-weight: 700;
            text-transform: uppercase;
            text-align: center;
            position: relative;
            color: transparent;
            /* Hide base text */
            letter-spacing: clamp(4px, 2vw, 20px);
            /* Reduced min spacing */
            /* Wide spacing for drama */
            line-height: 1.1;
            user-select: none;
            white-space: nowrap;
            /* Prevent wrapping unless absolutely necessary */
            max-width: 100%;
        }

        /* Mobile specific adjustment for title if it still overflows */
        @media (max-width: 480px) {
            .shattered-text {
                white-space: normal;
                /* Allow wrap on very small screens */
                font-size: clamp(32px, 10vw, 40px);
                line-height: 1.2;
            }

            .menu-title-container {
                margin-bottom: 40px;
            }
        }

        /* The Layers */
        .shattered-text::before,
        .shattered-text::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #fff 0%, #e0e0e0 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            opacity: 0.8;
        }

        /* Layer 1: Cyan/Blue drift */
        .shattered-text::before {
            text-shadow: -2px 0 #00f3ff;
            clip-path: polygon(0 0, 100% 0, 85% 35%, 15% 35%, 0 0,
                    0 65%, 15% 65%, 85% 65%, 100% 65%, 100% 100%, 0 100%);
            animation: shatter-drift-1 4s infinite linear alternate-reverse;
            z-index: 2;
        }

        /* Layer 2: Magenta/Pink drift */
        .shattered-text::after {
            text-shadow: 2px 0 #bc13fe;
            clip-path: polygon(15% 35%, 85% 35%, 100% 65%, 0 65%);
            animation: shatter-drift-2 4s infinite linear alternate;
            z-index: 3;
            filter: brightness(1.2);
        }

        /* Actual Visible Base Layer (White Core) */
        .shattered-base {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #ffffff, #a5b4fc);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            z-index: 1;
            opacity: 0.9;
            mix-blend-mode: overlay;
        }

        /* Floating Geometry Shards decoration around title */
        .title-shard {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 10px #00f3ff, 0 0 20px #bc13fe;
            border-radius: 2px;
            opacity: 0;
            animation: shard-twinkle 3s infinite;
        }

        /* Shard Animations */
        @keyframes shatter-drift-1 {
            0% {
                transform: translate(0, 0) skew(0deg);
                clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
            }

            20% {
                transform: translate(-2px, 1px) skew(-2deg);
                clip-path: polygon(0 0, 100% 0, 90% 40%, 10% 40%);
            }

            40% {
                transform: translate(2px, -1px) skew(1deg);
                clip-path: polygon(0 0, 100% 0, 100% 30%, 0 30%);
            }

            60% {
                transform: translate(-1px, 2px) skew(0deg);
                clip-path: polygon(0 0, 100% 0, 85% 50%, 15% 50%);
            }

            80% {
                transform: translate(1px, -2px) skew(2deg);
                clip-path: polygon(0 0, 100% 0, 100% 35%, 0 35%);
            }

            100% {
                transform: translate(0, 0) skew(0deg);
                clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
            }
        }

        @keyframes shatter-drift-2 {
            0% {
                transform: translate(0, 0);
                clip-path: polygon(0 45%, 100% 45%, 100% 100%, 0 100%);
            }

            20% {
                transform: translate(2px, -1px);
                clip-path: polygon(10% 40%, 90% 40%, 100% 100%, 0 100%);
            }

            40% {
                transform: translate(-2px, 1px);
                clip-path: polygon(0 30%, 100% 30%, 100% 100%, 0 100%);
            }

            60% {
                transform: translate(1px, -2px);
                clip-path: polygon(15% 50%, 85% 50%, 100% 100%, 0 100%);
            }

            80% {
                transform: translate(-1px, 2px);
                clip-path: polygon(0 35%, 100% 35%, 100% 100%, 0 100%);
            }

            100% {
                transform: translate(0, 0);
                clip-path: polygon(0 45%, 100% 45%, 100% 100%, 0 100%);
            }
        }

        @keyframes shard-twinkle {

            0%,
            100% {
                opacity: 0;
                transform: translateY(0) rotate(0deg);
            }

            50% {
                opacity: 1;
                transform: translateY(-10px) rotate(45deg);
            }
        }

        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 24px;
            width: 100%;
            max-width: 400px;
            padding: 0 20px;
        }

        .menu-btn {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: clamp(16px, 2.5vw, 24px);
            font-weight: 600;
            padding: clamp(16px, 3vw, 24px) clamp(24px, 4vw, 32px);
            /* Responsive padding */
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            /* Mobile touch handling */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            min-height: 56px;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0) 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .menu-btn:hover {
            transform: translateY(-4px) scale(1.02);
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
        }

        .menu-btn:hover::before {
            opacity: 1;
        }

        .menu-btn:active {
            transform: translateY(-2px) scale(0.98);
        }

        .menu-btn-icon {
            font-size: 1.2em;
        }

        /* Fun Game Mode Specifics */
        .menu-btn.fun-mode {
            border-color: rgba(237, 137, 54, 0.3);
        }

        .menu-btn.fun-mode:hover {
            border-color: #ed8936;
            box-shadow: 0 0 20px rgba(237, 137, 54, 0.3);
        }

        /* Polygon Fun Game Controls */
        .game-controls {
            position: absolute;
            bottom: clamp(16px, 2vw, 24px);
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 8px;
            z-index: 1500;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 10px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(6px);
        }

        .game-controls button {
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.15s ease, opacity 0.2s ease;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 36px;
            font-size: 14px;
        }

        .game-controls button.secondary {
            min-width: 36px;
            padding: 8px;
            font-size: 18px;
            line-height: 1;
        }

        .game-controls button.secondary {
            background: #edf2f7;
            color: #2d3748;
        }

        .game-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .game-controls button:hover:not(:disabled) {
            transform: translateY(-1px);
        }

        .game-results-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at top, rgba(59, 130, 246, 0.35), rgba(15, 23, 42, 0.78));
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10200;
            /* Above game UI */
            padding: 24px;
            backdrop-filter: blur(8px);
            /* Mobile touch handling */
            -webkit-overflow-scrolling: touch;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .game-results-panel {
            position: relative;
            background: white;
            border-radius: 28px;
            max-width: min(92vw, 760px);
            width: 100%;
            padding: 28px;
            box-shadow: 0 26px 50px rgba(15, 23, 42, 0.3);
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow: hidden;
            transform: translateY(12px) scale(0.98);
            animation: results-pop 0.5s ease forwards;
        }

        .game-results-panel::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(236, 72, 153, 0.08));
            pointer-events: none;
        }

        .game-results-panel.victory {
            border: 3px solid rgba(34, 197, 94, 0.3);
        }

        .game-results-panel.failed {
            border: 3px solid rgba(248, 113, 113, 0.35);
        }

        .game-results-stars {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 32px;
            color: #fbbf24;
            filter: drop-shadow(0 2px 4px rgba(251, 191, 36, 0.3));
        }

        .game-results-title {
            font-size: clamp(28px, 3.6vw, 40px);
            font-weight: 900;
            letter-spacing: 0.5px;
            color: #1e293b;
        }

        .game-results-title span {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .game-results-panel.failed .game-results-title span {
            background: linear-gradient(135deg, #fb7185, #f97316);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .game-results-subtitle {
            font-size: clamp(14px, 2vw, 18px);
            font-weight: 600;
            color: #475569;
        }

        .game-results-coin {
            font-size: clamp(16px, 2vw, 20px);
            font-weight: 700;
            color: #b45309;
            background: #fff7ed;
            border-radius: 999px;
            padding: 8px 14px;
            width: fit-content;
        }

        .game-results-reason {
            font-size: 16px;
            color: #ef4444;
            font-weight: 700;
            background: #fff1f2;
            border-radius: 12px;
            padding: 8px 12px;
        }

        .game-results-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-results-badge {
            background: #ecfeff;
            color: #0e7490;
            border-radius: 999px;
            padding: 6px 12px;
            font-size: 13px;
            font-weight: 700;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .game-results-panel.failed .game-results-badge {
            background: #fff7ed;
            color: #c2410c;
        }

        .game-results-sticker {
            position: absolute;
            top: 18px;
            right: 18px;
            background: #fef9c3;
            color: #ca8a04;
            font-weight: 800;
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 14px;
            transform: rotate(6deg);
            box-shadow: 0 10px 20px rgba(202, 138, 4, 0.25);
        }

        .game-results-panel.failed .game-results-sticker {
            background: #fee2e2;
            color: #dc2626;
            transform: rotate(-6deg);
        }

        .game-results-confetti {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .game-results-confetti span {
            position: absolute;
            width: 10px;
            height: 18px;
            border-radius: 4px;
            opacity: 0;
            animation: confetti-fall 1.6s ease-in-out infinite;
        }

        .game-results-panel.failed .game-results-confetti {
            display: none;
        }

        @keyframes results-pop {
            0% {
                transform: translateY(24px) scale(0.94);
                opacity: 0;
            }

            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-40px) rotate(0deg);
                opacity: 0;
            }

            30% {
                opacity: 1;
            }

            100% {
                transform: translateY(380px) rotate(180deg);
                opacity: 0;
            }
        }

        .game-results-breakdown {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
            gap: 16px;
            align-items: start;
        }

        .game-results-canvas {
            width: 100%;
            height: 240px;
            border-radius: 16px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
        }

        .game-results-piece-list {
            background: #f8fafc;
            border-radius: 16px;
            padding: 12px 16px;
            border: 1px solid #e2e8f0;
            max-height: 240px;
            overflow-y: auto;
            font-size: 14px;
        }

        .game-results-piece-list div {
            padding: 6px 0;
            border-bottom: 1px dashed #e2e8f0;
        }

        .game-results-piece-list div:last-child {
            border-bottom: none;
        }

        .game-results-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: flex-end;
        }

        .game-results-actions button {
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.15s ease, opacity 0.2s ease;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 44px;
        }

        .game-results-actions button.secondary {
            background: #edf2f7;
            color: #2d3748;
        }

        .game-results-actions button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        @media (max-width: 768px) {
            .game-results-breakdown {
                grid-template-columns: 1fr;
            }
        }

        @keyframes pulse-border {
            0% {
                box-shadow: 0 0 0 0 rgba(72, 187, 120, 1);
                transform: scale(1);
            }

            50% {
                transform: scale(1.08);
                box-shadow: 0 0 25px 5px rgba(72, 187, 120, 0.6);
            }

            70% {
                box-shadow: 0 0 0 20px rgba(72, 187, 120, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(72, 187, 120, 0);
                transform: scale(1);
            }
        }

        .submit-ready {
            animation: pulse-border 1.2s infinite cubic-bezier(0.66, 0, 0, 1);
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%) !important;
            font-weight: 800 !important;
            letter-spacing: 0.5px;
            z-index: 10;
        }

        .box-score-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.72);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10500;
            /* Above game panels */
            padding: 24px;
            backdrop-filter: blur(10px);
            /* Mobile touch handling */
            -webkit-overflow-scrolling: touch;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .box-score-panel {
            width: min(96vw, 1100px);
            height: min(92vh, 720px);
            background: white;
            border-radius: 26px;
            box-shadow: 0 30px 60px rgba(15, 23, 42, 0.4);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(226, 232, 240, 0.8);
        }

        .box-score-header {
            padding: 22px 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 24px;
        }

        .box-score-title {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .box-score-title h2 {
            margin: 0;
            font-size: clamp(20px, 3vw, 30px);
            font-weight: 800;
            letter-spacing: 0.3px;
        }

        .box-score-title span {
            font-size: 14px;
            opacity: 0.85;
        }

        .box-score-meta {
            font-size: 12px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.85);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .box-score-meta .status-pill {
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 10px;
            border-radius: 999px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .box-score-total {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
            font-weight: 700;
        }

        .box-score-total strong {
            font-size: clamp(20px, 3vw, 28px);
        }

        .box-score-close {
            border: none;
            background: rgba(255, 255, 255, 0.25);
            color: white;
            font-size: 20px;
            border-radius: 12px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .box-score-close:hover {
            background: rgba(255, 255, 255, 0.35);
        }

        .box-score-body {
            flex: 1;
            display: grid;
            grid-template-columns: minmax(280px, 1fr) 1.2fr;
            gap: 24px;
            padding: 24px;
            overflow: hidden;
            background: linear-gradient(180deg, #f8fafc 0%, #ffffff 40%);
        }

        .level-preview-panel {
            background: white;
            border-radius: 20px;
            border: 1px solid #e2e8f0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.03);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #levelPreviewCanvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .level-preview-overlay {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 16px;
            border-radius: 99px;
            border: 1px solid #e2e8f0;
            font-size: 14px;
            font-weight: 600;
            color: #475569;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .box-score-slots {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            padding-right: 6px;
        }

        .box-score-slot {
            border-radius: 14px;
            border: 1px solid #e2e8f0;
            padding: 12px;
            background: white;
            display: flex;
            flex-direction: column;
            gap: 6px;
            box-shadow: 0 6px 14px rgba(148, 163, 184, 0.14);
        }

        .box-score-slot.active {
            border-color: #667eea;
            background: #eef2ff;
            box-shadow: 0 12px 24px rgba(102, 126, 234, 0.25);
        }

        .box-score-slot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 700;
            color: #1f2937;
            gap: 8px;
        }

        .box-score-slot-title {
            font-size: 12px;
            letter-spacing: 0.2px;
        }

        .box-score-slot-status {
            font-size: 10px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.35px;
        }

        .box-score-slot-stars {
            font-size: 12px;
            font-weight: 700;
            color: #f59e0b;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .box-score-slot-date {
            font-size: 10px;
            color: #6b7280;
        }

        .box-score-slot-actions {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 6px;
            width: 100%;
            align-items: stretch;
        }

        .box-score-slot-actions button {
            border: none;
            border-radius: 8px;
            padding: 4px 8px;
            font-weight: 700;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 10px;
            min-height: 28px;
            width: 100%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            white-space: nowrap;
            transition: transform 0.15s ease, opacity 0.2s ease;
        }

        .box-score-slot-actions button.secondary {
            background: #e2e8f0;
            color: #1f2937;
        }

        .box-score-slot-actions button.danger {
            background: #fee2e2;
            color: #b91c1c;
        }

        .box-score-slot-actions button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .box-score-slot-progress {
            width: 100%;
            height: 6px;
            border-radius: 999px;
            background: #e2e8f0;
            overflow: hidden;
        }

        .box-score-slot-progress span {
            display: block;
            height: 100%;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            width: 0;
            transition: width 0.2s ease;
        }

        .box-score-slot-badges {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .box-score-slot-badge {
            font-size: 9px;
            font-weight: 700;
            padding: 3px 6px;
            border-radius: 999px;
            background: #e0e7ff;
            color: #4338ca;
            text-transform: uppercase;
            letter-spacing: 0.35px;
        }

        .box-score-grid {
            background: #f8fafc;
            border-radius: 20px;
            border: 1px solid #e2e8f0;
            padding: 16px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }

        .box-score-level {
            background: white;
            border-radius: 14px;
            padding: 12px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            border: 1px solid #e2e8f0;
            font-size: 13px;
            font-weight: 600;
            color: #334155;
        }

        .box-score-level.selectable {
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }

        .box-score-level.selectable:hover {
            transform: translateY(-2px);
            border-color: #667eea;
            box-shadow: 0 8px 16px rgba(102, 126, 234, 0.18);
        }

        .box-score-level.locked {
            opacity: 0.6;
            background: #f1f5f9;
            color: #94a3b8;
        }

        .box-score-level.current {
            border-color: #16a34a;
            box-shadow: 0 0 0 2px rgba(22, 163, 74, 0.15);
        }

        .box-score-level-title {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .box-score-level-status {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            color: #64748b;
        }

        .box-score-stars {
            display: flex;
            gap: 4px;
            font-size: 16px;
            color: #f59e0b;
        }

        .box-score-star.empty {
            color: #cbd5f5;
        }

        @media (max-width: 768px) {
            .box-score-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .box-score-total {
                align-items: flex-start;
            }

            .box-score-body {
                grid-template-columns: 1fr;
            }

            .box-score-panel {
                height: min(94vh, 760px);
            }
        }
    </style>
</head>

<body>

    <!-- Main Menu Overlay -->
    <div id="mainMenuOverlay">
        <canvas id="bgCanvas"
            style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;"></canvas>
        <!-- Shattered Prism Title -->
        <div class="menu-title-container">
            <!-- Decorative Shards -->


            <div class="title-shard" style="top: 50%; right: -30px; width: 15px; height: 15px; animation-delay: 2s;">
            </div>

            <div class="shattered-text" data-text="POLYGON FUN">
                POLYGON FUN
                <div class="shattered-base">POLYGON FUN</div>
            </div>
        </div>
        <div class="menu-options">
            <button class="menu-btn fun-mode" id="btnFunMode">
                <span class="menu-btn-icon">ðŸŽ®</span>
                <span>Play Game</span>
            </button>
        </div>
    </div>

    <div id="funTransitionOverlay" aria-hidden="true">
        <div class="fun-transition-core">
            <div class="fun-transition-title">Entering Polygon Fun Game</div>
            <div class="fun-transition-subtitle">Syncing geometry & warming up the arena...</div>
            <div class="fun-transition-bar"><span></span></div>
        </div>
    </div>

    <div class="fun-game-start-overlay" id="funGameStartOverlay" aria-hidden="true">
        <div class="fun-game-start-panel" role="dialog" aria-modal="true" aria-labelledby="funGameStartTitle">
            <div class="fun-game-start-header">
                <h3 id="funGameStartTitle">Polygon Fun Game</h3>
                <button class="fun-game-start-close" id="funGameStartClose" aria-label="Close">âœ•</button>
            </div>
            <div class="fun-game-start-body">
                <p>Pick how you want to jump back into the action.</p>
                <div class="fun-game-start-meta" id="funGameStartMeta">Checking save slots...</div>
            </div>
            <div class="fun-game-start-actions">
                <button class="primary" id="funGameStartNew">New Game</button>
                <div class="fun-game-start-slots" id="funGameStartSlots"></div>
            </div>
        </div>
    </div>

    <div class="app-dialog-overlay" id="appDialogOverlay" aria-hidden="true">
        <div class="app-dialog-panel" role="dialog" aria-modal="true" aria-labelledby="appDialogTitle">
            <div class="app-dialog-header">
                <span id="appDialogTitle">Confirm Action</span>
                <button class="app-dialog-close" id="appDialogClose" aria-label="Close">âœ•</button>
            </div>
            <div class="app-dialog-body" id="appDialogBody"></div>
            <div class="app-dialog-actions">
                <button class="app-dialog-btn secondary" id="appDialogCancel">Cancel</button>
                <button class="app-dialog-btn primary" id="appDialogConfirm">Confirm</button>
            </div>
        </div>
    </div>

    <div class="app-container">
        <!-- Main Body Row (Sidebars + Canvas) -->
        <div class="main-body-row" style="display: flex; flex: 1; min-height: 0; width: 100%; position: relative;">

            <!-- Mobile Sidebar Backdrop -->
            <div class="sidebar-backdrop" id="sidebarBackdrop"></div>

            <!-- Left Sidebar -->
            <div class="sidebar">

                <!-- Wrapper for Layers Panel full height -->
                <div class="resizable-panel" id="layersPanel" style="height: 100%; flex: 1;">
                    <!-- Layers Panel -->
                    <div class="panel-header">
                        <button class="panel-back-btn" id="layersBackBtn" aria-label="Close Layers Panel">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 12H5M12 19l-7-7 7-7" />
                            </svg>
                        </button>
                        <span>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                                style="display: inline-block; vertical-align: middle; margin-right: 6px;">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                                <rect x="7" y="7" width="10" height="10" rx="1" ry="1" />
                                <rect x="11" y="11" width="6" height="6" rx="0.5" ry="0.5" />
                            </svg>
                            Layers
                        </span>
                        <span id="layerCount">0</span>
                    </div>
                    <div class="resizable-panel-content">
                        <!-- Create New Polygon Button -->
                        <div class="create-polygon-container">
                            <button id="createPolygonBtn" class="create-polygon-btn"
                                aria-label="Open create new polygon menu">
                                <svg class="btn-icon" width="20" height="20" viewBox="0 0 24 24" fill="none"
                                    stroke="currentColor" stroke-width="2">
                                    <path d="M12 2L2 7L2 17L12 22L22 17L22 7L12 2Z" />
                                </svg>
                                <span>Create New Polygon</span>
                            </button>
                        </div>

                        <!-- Layers List -->
                        <div id="layersList"></div>
                    </div>
                </div>
            </div>

            <!-- Canvas Container -->
            <div class="canvas-container" id="canvasContainer">
                <canvas id="mainCanvas"></canvas>

                <!-- Toolbar -->
                <div class="toolbar">
                    <button class="tool-btn" id="toolbarCreateBtn" data-tooltip="Create New Polygon">âž•</button>
                    <button class="tool-btn active" data-tool="select" data-tooltip="Select/Move (S)">âœ‹</button>

                    <!-- Color Picker Button -->
                    <div style="position: relative; display: inline-flex;">
                        <button class="tool-btn" id="toolbarColorBtn" data-tooltip="Change Color">ðŸŽ¨</button>
                        <input type="color" id="toolbarColorInput" value="#667eea"
                            style="position: absolute; opacity: 0; width: 0; height: 0; pointer-events: none;">
                    </div>

                    <button class="tool-btn combine-btn" data-tool="combine"
                        data-tooltip="Combine Polygons">Combine</button>
                    <button class="tool-btn combine-btn" id="cancelCombineBtn"
                        style="display: none; background: #e53e3e; color: white;"
                        data-tooltip="Cancel Combine">Cancel</button>
                    <button class="tool-btn split-btn" data-tool="split" data-tooltip="Split Polygon">Split</button>
                    <button class="tool-btn split-btn" id="cancelSplitBtn"
                        style="display: none; background: #e53e3e; color: white;"
                        data-tooltip="Cancel Split">Cancel</button>
                    <button class="tool-btn" data-tool="undo" data-tooltip="Undo (Ctrl+Z)">â†¶</button>
                    <button class="tool-btn" data-tool="redo" data-tooltip="Redo (Ctrl+Y)">â†·</button>
                </div>

                <!-- Top Tools Bar (Tabs) -->
                <div class="top-tools-bar">
                    <button class="fullscreen-top-btn" id="fullscreenToggle" title="Toggle Fullscreen">â¤¢</button>
                </div>

                <!-- Viewport Controls (Pan + Zoom) -->
                <div class="viewport-controls" aria-label="Viewport controls">
                    <div class="pan-controls" aria-label="Pan controls">
                        <button class="zoom-btn" id="zoomIn" aria-label="Zoom in">+</button>
                        <button class="pan-btn control-btn-blue" id="panUp" aria-label="Pan up">â†‘</button>
                        <button class="zoom-btn" id="zoomOut" aria-label="Zoom out">-</button>

                        <button class="pan-btn control-btn-blue" id="panLeft" aria-label="Pan left">â†</button>
                        <button class="pan-btn control-btn-blue" id="panDown" aria-label="Pan down">â†“</button>
                        <button class="pan-btn control-btn-blue" id="panRight" aria-label="Pan right">â†’</button>
                    </div>

                    <label class="grid-snap-controls" for="gridSnapToggle" aria-label="Grid snap control">
                        <input type="checkbox" id="gridSnapToggle" checked aria-label="Toggle grid snap"
                            title="Toggle grid snap">
                        <span class="grid-snap-label" id="gridSnapLabel">Grid Snap: On</span>
                    </label>
                </div>

                <!-- Coordinate Display -->
                <div class="coord-display" id="coordDisplay">X: 0, Y: 0</div>

                <!-- Polygon Fun Game Controls -->
                <div class="game-controls" id="gameControls">
                    <button class="secondary" id="gameUndoBtn" aria-label="Undo" title="Undo">â†¶</button>
                    <button class="secondary" id="gameRedoBtn" aria-label="Redo" title="Redo">â†·</button>
                    <button id="gameSubmitBtn">Submit</button>
                </div>
            </div>

            <!-- Right Sidebar -->
            <div class="sidebar sidebar-right">
                <!-- Visualizers Panel -->
                <div class="panel">
                    <div class="panel-header">
                        <button class="panel-back-btn" id="visualizersBackBtn" aria-label="Close Visualizers Panel">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 12H5M12 19l-7-7 7-7" />
                            </svg>
                        </button>
                        <span>ðŸ‘ï¸ Visualizers</span>
                    </div>
                    <div class="panel-content">
                        <div class="viz-item" data-viz="angles">
                            <div class="visualizer-checkbox"></div>
                            <div class="viz-item-title">Show Angles</div>
                        </div>
                        <div class="viz-item" data-viz="medians">
                            <div class="visualizer-checkbox"></div>
                            <div class="viz-item-title">Show Medians &amp; Centroid</div>
                        </div>
                        <div class="viz-item" data-viz="altitudes">
                            <div class="visualizer-checkbox"></div>
                            <div class="viz-item-title">Show Altitudes &amp; Orthocenter</div>
                        </div>
                        <div class="viz-item" data-viz="bisectors">
                            <div class="visualizer-checkbox"></div>
                            <div class="viz-item-title">Show Perpendicular Bisectors</div>
                        </div>
                        <div class="viz-item" data-viz="diagonals">
                            <div class="visualizer-checkbox"></div>
                            <div class="viz-item-title">Show Diagonals</div>
                        </div>
                        <div class="viz-item" data-viz="vertices">
                            <div class="visualizer-checkbox"></div>
                            <div class="viz-item-title">Show Vertices</div>
                        </div>
                        <div class="viz-item" data-viz="perimeters">
                            <div class="visualizer-checkbox"></div>
                            <div class="viz-item-title">Show Perimeters</div>
                        </div>
                        <div class="viz-item" data-viz="baseHeight">
                            <div class="visualizer-checkbox"></div>
                            <div class="viz-item-title">Show Base &amp; Height</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Properties Panel -->
        <div id="bottomPropertiesPanel" class="bottom-panel expanded">
            <div class="bottom-panel-header">
                <div class="bottom-panel-title">
                    <span>ðŸ“Š Properties</span>
                </div>
                <button class="bottom-panel-toggle" id="bottomPanelToggle">
                    <span class="toggle-icon">â–¼</span>
                </button>
            </div>
            <div class="bottom-panel-content" id="propertiesPanelContent">
                <div class="property-row" style="justify-content: center; padding: 12px;">
                    <span class="property-label" style="color: #94a3b8; font-style: italic;">Select a polygon to view
                        properties</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Combine Tool Modal -->
    <!-- Combine Tool Modal -->
    <div class="modal-overlay" id="combineModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Combine Polygons</span>
                <button class="modal-close-btn"
                    onclick="document.getElementById('combineModal').style.display = 'none'">&times;</button>
            </div>
            <div class="modal-body">
                Please select two or more polygons to combine them into a single morphed polygon.
            </div>
            <div class="modal-footer">
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="combineDontShowAgain">
                    Don't show this again
                </label>
                <button class="modal-btn" id="combineContinueBtn">Continue</button>
            </div>
        </div>
    </div>

    <!-- Split Tool Modal -->
    <div class="modal-overlay" id="splitModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Split Polygon</span>
                <button class="modal-close-btn"
                    onclick="document.getElementById('splitModal').style.display = 'none'">&times;</button>
            </div>
            <div class="modal-body">
                Use the Line vector to split your polygon into two pieces.
            </div>
            <div class="modal-footer">
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="splitDontShowAgain">
                    Don't show this again
                </label>
                <button class="modal-btn" id="splitContinueBtn">Continue</button>
            </div>
        </div>
    </div>

    <!-- Combine Selection Error Modal -->
    <div class="modal-overlay" id="combineSelectionModal" style="z-index: 3100;">
        <div class="modal-content" style="max-width: 400px; text-align: center;">
            <div class="modal-header" style="justify-content: center;">
                <span class="modal-title">Select Polygons</span>
            </div>
            <div class="modal-body">
                Please select at least two polygons to combine.
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="modal-btn"
                    onclick="document.getElementById('combineSelectionModal').style.display = 'none'">OK</button>
            </div>
        </div>
    </div>

    <!-- Split Selection Confirmation Modal -->
    <div class="modal-overlay" id="splitConfirmSelectionModal">
        <div class="modal-content" style="max-width: 300px; text-align: center;">
            <div class="modal-header" style="justify-content: center;">Confirm Selection</div>
            <div class="modal-body">
                Do you want to split this polygon?
            </div>
            <div class="modal-footer" style="flex-direction: row; justify-content: center;">
                <button class="modal-btn" style="background: #e1e4e8; color: #1a202c;"
                    id="splitCancelSelectionBtn">Cancel</button>
                <button class="modal-btn" style="background: #667eea; color: white;"
                    id="splitConfirmSelectionBtnModal">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Reset Confirmation Modal -->
    <div class="modal-overlay" id="resetModal">
        <div class="modal-content">
            <div class="modal-header" style="color: #e53e3e;">âš ï¸ Reset Everything?</div>
            <div class="modal-body">
                This will clear the entire canvas and cannot be undone. Are you sure you want to proceed?
            </div>
            <div class="modal-footer" style="flex-direction: row; justify-content: flex-end;">
                <button class="modal-btn" id="cancelResetBtn"
                    style="background: #edf2f7; color: #4a5568;">Cancel</button>
                <button class="modal-btn" id="confirmResetBtn" style="background: #e53e3e; color: white;">Yes,
                    Reset</button>
            </div>
        </div>
    </div>

    <!-- Create Shape Modal -->
    <div class="modal-overlay" id="createShapeModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <span>Create New Polygon</span>
                <button id="closeCreateShapeModal" class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 20px; color: #4a5568; font-size: 15px;">Which shape polygon would you like to
                    create?</p>
                <div class="shape-grid"
                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px;">
                    <div class="shape-option-card" data-shape="triangle" data-sides="3">
                        <div class="shape-icon">â–²</div>
                        <div class="shape-name">Triangle</div>
                        <div class="shape-hint">3 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="square" data-sides="4">
                        <div class="shape-icon">â– </div>
                        <div class="shape-name">Square</div>
                        <div class="shape-hint">4 equal sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="rectangle" data-sides="4">
                        <div class="shape-icon">â–¬</div>
                        <div class="shape-name">Rectangle</div>
                        <div class="shape-hint">4 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="pentagon" data-sides="5">
                        <div class="shape-icon">â¬Ÿ</div>
                        <div class="shape-name">Pentagon</div>
                        <div class="shape-hint">5 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="hexagon" data-sides="6">
                        <div class="shape-icon">â¬¢</div>
                        <div class="shape-name">Hexagon</div>
                        <div class="shape-hint">6 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="heptagon" data-sides="7">
                        <div class="shape-icon">â¬ </div>
                        <div class="shape-name">Heptagon</div>
                        <div class="shape-hint">7 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="octagon" data-sides="8">
                        <div class="shape-icon">â¬¡</div>
                        <div class="shape-name">Octagon</div>
                        <div class="shape-hint">8 sides</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Message Modal -->
    <div class="modal-overlay" id="gameMessageModal" style="z-index: 4000;">
        <div class="modal-content" style="max-width: 400px; text-align: center;">
            <div class="modal-header" style="justify-content: center;">
                <span class="modal-title" id="gameMessageTitle" style="font-size: 24px;">Level Complete!</span>
            </div>
            <div class="modal-body" id="gameMessageBody" style="font-size: 18px; margin-bottom: 24px;">
                Great job! You made a perfect split.
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="modal-btn" id="gameMessageBtn">Next Level</button>
            </div>
        </div>
    </div>
    <!-- Polygon Fun Game Results Overlay -->
    <div class="game-results-overlay" id="gameResultsOverlay">
        <div class="game-results-panel" id="gameResultsPanel">
            <div class="game-results-confetti" aria-hidden="true">
                <span style="left: 10%; background: #38bdf8; animation-delay: 0s;"></span>
                <span style="left: 20%; background: #f472b6; animation-delay: 0.2s;"></span>
                <span style="left: 30%; background: #34d399; animation-delay: 0.4s;"></span>
                <span style="left: 40%; background: #fbbf24; animation-delay: 0.1s;"></span>
                <span style="left: 50%; background: #c4b5fd; animation-delay: 0.3s;"></span>
                <span style="left: 60%; background: #fb7185; animation-delay: 0.5s;"></span>
                <span style="left: 70%; background: #60a5fa; animation-delay: 0.15s;"></span>
                <span style="left: 80%; background: #facc15; animation-delay: 0.35s;"></span>
                <span style="left: 90%; background: #4ade80; animation-delay: 0.25s;"></span>
            </div>
            <div class="game-results-sticker" id="gameResultsSticker">ðŸŽ‰ Awesome!</div>
            <div class="game-results-stars" id="gameResultsStars"></div>
            <div class="game-results-title" id="gameResultsTitle"><span>Victory!</span></div>
            <div class="game-results-subtitle" id="gameResultsSubtitle">You split it like a pro!</div>
            <div class="game-results-badges" id="gameResultsBadges">
                <span class="game-results-badge">ðŸ† Level Clear</span>
                <span class="game-results-badge">âœ¨ Keep Going</span>
            </div>
            <div class="game-results-coin" id="gameResultsCoin"></div>
            <div class="game-results-reason" id="gameResultsReason" style="display: none;"></div>
            <div class="game-results-breakdown">
                <canvas class="game-results-canvas" id="gameResultsCanvas"></canvas>
                <div class="game-results-piece-list" id="gameResultsPieces"></div>
            </div>
            <div class="game-results-actions">
                <button class="secondary" id="gameResultsRetry">Retry</button>
                <button id="gameResultsNext">Next Level</button>
                <button class="secondary" id="gameResultsMenu">Main Menu</button>
            </div>
        </div>
    </div>

    <div class="box-score-overlay" id="boxScoreOverlay" aria-hidden="true">
        <div class="box-score-panel">
            <div class="box-score-header">
                <div class="box-score-title">
                    <h2>Select Level</h2>
                    <span>Track your star rating.</span>
                    <div class="box-score-meta">
                        <span id="boxScoreActiveSlot">Active Slot: 1</span>
                        <span class="status-pill" id="boxScoreSaveType">Autosave Ready</span>
                        <span id="boxScoreLastSave">Last save: --</span>
                    </div>
                </div>
                <div class="box-score-total">
                    <span>Total Stars</span>
                    <strong id="boxScoreTotal">0 / 90</strong>
                </div>
                <button class="box-score-close" id="boxScoreClose" aria-label="Close Box Score">âœ•</button>
            </div>
            <div class="box-score-body">
                <div class="box-score-slots" id="boxScoreSlots"></div>
                <div class="box-score-grid" id="boxScoreGrid"></div>
                <div class="level-preview-panel" id="levelPreviewPanel">
                    <canvas id="levelPreviewCanvas"></canvas>
                    <div class="level-preview-overlay" id="levelPreviewOverlay">
                        <span id="levelPreviewTitle">Level Preview</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="js/geometry.js"></script>
    <script src="js/levels.js"></script>
    <script src="js/game.js"></script>
    <script>
        const AppDialog = (() => {
            let overlay;
            let titleEl;
            let bodyEl;
            let confirmBtn;
            let cancelBtn;
            let closeBtn;
            let resolver;
            let escListener;

            const ensureElements = () => {
                if (overlay) return true;
                overlay = document.getElementById('appDialogOverlay');
                titleEl = document.getElementById('appDialogTitle');
                bodyEl = document.getElementById('appDialogBody');
                confirmBtn = document.getElementById('appDialogConfirm');
                cancelBtn = document.getElementById('appDialogCancel');
                closeBtn = document.getElementById('appDialogClose');

                if (!overlay || !titleEl || !bodyEl || !confirmBtn || !cancelBtn || !closeBtn) {
                    return false;
                }

                confirmBtn.addEventListener('click', () => closeDialog(true));
                cancelBtn.addEventListener('click', () => closeDialog(false));
                closeBtn.addEventListener('click', () => closeDialog(false));
                overlay.addEventListener('click', (event) => {
                    if (event.target === overlay && overlay.dataset.allowCancel === 'true') {
                        closeDialog(false);
                    }
                });
                return true;
            };

            const attachEscapeListener = () => {
                if (escListener) {
                    document.removeEventListener('keydown', escListener);
                }
                escListener = (event) => {
                    if (event.key === 'Escape' && overlay?.dataset.allowCancel === 'true') {
                        closeDialog(false);
                    }
                };
                document.addEventListener('keydown', escListener);
            };

            const openDialog = ({
                title = 'Confirm Action',
                message = '',
                confirmText = 'Confirm',
                cancelText = 'Cancel',
                allowCancel = true
            } = {}) => {
                if (!ensureElements()) {
                    return Promise.resolve(false);
                }

                titleEl.textContent = title;
                bodyEl.textContent = message;
                confirmBtn.textContent = confirmText;
                cancelBtn.textContent = cancelText;
                cancelBtn.style.display = allowCancel ? 'inline-flex' : 'none';
                closeBtn.style.display = allowCancel ? 'inline-flex' : 'none';
                overlay.dataset.allowCancel = allowCancel ? 'true' : 'false';
                overlay.style.display = 'flex';
                overlay.setAttribute('aria-hidden', 'false');
                document.body.style.overflow = 'hidden';

                attachEscapeListener();

                return new Promise((resolve) => {
                    resolver = resolve;
                    setTimeout(() => {
                        confirmBtn.focus();
                    }, 0);
                });
            };

            const closeDialog = (result) => {
                if (!overlay) return;
                overlay.style.display = 'none';
                overlay.setAttribute('aria-hidden', 'true');
                document.body.style.overflow = '';
                if (escListener) {
                    document.removeEventListener('keydown', escListener);
                    escListener = null;
                }
                if (resolver) {
                    const callback = resolver;
                    resolver = null;
                    callback(result);
                }
            };

            const confirm = (message, options = {}) => openDialog({
                ...options,
                message,
                allowCancel: true,
                confirmText: options.confirmText || 'Confirm',
                cancelText: options.cancelText || 'Cancel'
            });

            const alert = (message, options = {}) => openDialog({
                ...options,
                message,
                allowCancel: false,
                confirmText: options.confirmText || 'OK'
            });

            return {
                confirm,
                alert,
                close: closeDialog
            };
        })();

        window.AppDialog = AppDialog;
        window.appConfirm = (message, options) => AppDialog.confirm(message, options);
        window.appAlert = (message, options) => AppDialog.alert(message, options);

        // Main Menu Logic
        const MainMenu = {
            overlay: document.getElementById('mainMenuOverlay'),
            btnFun: document.getElementById('btnFunMode'),

            init() {
                if (!this.overlay) return;

                // FUN MODE BUTTON: Handled by menu-fix.js to open popup panel
                // Do NOT add click handler here - menu-fix.js handles it with openFunPanel()
                // This prevents mobile race condition where this handler would bypass the popup

                // Ensure menu is visible on load
                this.show();
            },

            show() {
                if (!this.overlay) return;
                this.overlay.style.display = 'flex';
                this.overlay.style.pointerEvents = 'auto';
                this.overlay.classList.remove('hidden');

                // Always ensure main menu background music is active when menu is shown.
                if (typeof window.playBackgroundMusic === 'function') {
                    try {
                        window.playBackgroundMusic();
                    } catch (e) {
                        console.warn('[MainMenu] Failed to start background music:', e);
                    }
                }
            },

            hide() {
                if (!this.overlay) return;
                this.overlay.style.pointerEvents = 'none';
                this.overlay.classList.add('hidden');
            }
        };

        // Route safety guard: always resolve to this app shell entry.
        const ensureAppEntryRoute = () => {
            const path = window.location.pathname || '';
            const hash = window.location.hash || '';
            const isAppEntry = /(?:\/|\/index\.html)$/i.test(path);
            const hasRouterLikeHash = hash.startsWith('#/');

            if (!isAppEntry || hasRouterLikeHash) {
                window.history.replaceState(null, '', './index.html');
            }
        };

        // Initialize Main Menu when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            ensureAppEntryRoute();
            MainMenu.init();
        });

        // Register PWA manifest only on supported secure/network origins.
        // Prevents file:// origin "null" CORS noise during local file testing.
        (function registerManifestWhenSupported() {
            const protocol = window.location.protocol;
            const isSupportedOrigin = protocol === 'http:' || protocol === 'https:';
            if (!isSupportedOrigin) return;

            const existing = document.querySelector('link[rel="manifest"]');
            if (existing) return;

            const link = document.createElement('link');
            link.rel = 'manifest';
            link.href = 'manifest.json';
            document.head.appendChild(link);
        })();

        // Device Detection and Viewport Intelligence System
        class DeviceDetector {
            constructor() {
                this.deviceInfo = {
                    type: 'desktop',
                    isMobile: false,
                    isTablet: false,
                    isDesktop: true,
                    isTouch: false,
                    orientation: 'landscape',
                    screenWidth: window.innerWidth,
                    screenHeight: window.innerHeight,
                    aspectRatio: window.innerWidth / window.innerHeight,
                    pixelRatio: window.devicePixelRatio || 1
                };

                this.updateDeviceInfo();
                this.setupListeners();
                this.applyDeviceClasses();
            }

            updateDeviceInfo() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const aspectRatio = width / height;

                // Detect device type
                this.deviceInfo.screenWidth = width;
                this.deviceInfo.screenHeight = height;
                this.deviceInfo.aspectRatio = aspectRatio;
                this.deviceInfo.orientation = width > height ? 'landscape' : 'portrait';

                // Touch detection
                this.deviceInfo.isTouch = 'ontouchstart' in window ||
                    navigator.maxTouchPoints > 0 ||
                    navigator.msMaxTouchPoints > 0;

                // Device type detection
                if (width <= 768) {
                    this.deviceInfo.type = 'mobile';
                    this.deviceInfo.isMobile = true;
                    this.deviceInfo.isTablet = false;
                    this.deviceInfo.isDesktop = false;
                } else if (width <= 1024) {
                    this.deviceInfo.type = 'tablet';
                    this.deviceInfo.isMobile = false;
                    this.deviceInfo.isTablet = true;
                    this.deviceInfo.isDesktop = false;
                } else {
                    this.deviceInfo.type = 'desktop';
                    this.deviceInfo.isMobile = false;
                    this.deviceInfo.isTablet = false;
                    this.deviceInfo.isDesktop = true;
                }
            }

            setupListeners() {
                // Resize handler with debouncing
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.updateDeviceInfo();
                        this.applyDeviceClasses();
                        this.onResize();
                    }, 100);
                });

                // Orientation change handler
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.updateDeviceInfo();
                        this.applyDeviceClasses();
                        this.onOrientationChange();
                    }, 100);
                });

                // Touch detection
                document.addEventListener('touchstart', () => {
                    if (!this.deviceInfo.isTouch) {
                        this.deviceInfo.isTouch = true;
                        this.applyDeviceClasses();
                    }
                }, { once: true });
            }

            applyDeviceClasses() {
                const root = document.documentElement;
                const body = document.body;

                // Remove existing classes
                body.classList.remove('device-mobile', 'device-tablet', 'device-desktop',
                    'is-touch', 'is-mouse', 'orientation-portrait', 'orientation-landscape');

                // Add device type classes
                body.classList.add(`device-${this.deviceInfo.type}`);

                // Add touch/mouse classes
                if (this.deviceInfo.isTouch) {
                    body.classList.add('is-touch');
                } else {
                    body.classList.add('is-mouse');
                }

                // Add orientation classes
                body.classList.add(`orientation-${this.deviceInfo.orientation}`);

                // Set CSS custom properties
                root.style.setProperty('--is-mobile', this.deviceInfo.isMobile ? '1' : '0');
                root.style.setProperty('--is-tablet', this.deviceInfo.isTablet ? '1' : '0');
                root.style.setProperty('--is-desktop', this.deviceInfo.isDesktop ? '1' : '0');
                root.style.setProperty('--is-touch', this.deviceInfo.isTouch ? '1' : '0');
                root.style.setProperty('--is-portrait', this.deviceInfo.orientation === 'portrait' ? '1' : '0');
                root.style.setProperty('--is-landscape', this.deviceInfo.orientation === 'landscape' ? '1' : '0');
            }

            onResize() {
                // Trigger custom event for other components
                window.dispatchEvent(new CustomEvent('deviceResize', {
                    detail: this.deviceInfo
                }));
            }

            onOrientationChange() {
                // Trigger custom event for orientation changes
                window.dispatchEvent(new CustomEvent('deviceOrientationChange', {
                    detail: this.deviceInfo
                }));
            }

            getInfo() {
                return { ...this.deviceInfo };
            }
        }

        // Global device detector instance
        let deviceDetector;

        // Polygon Fun - Main Application
        class PolygonFunApp {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('canvasContainer');

                // Initialize device detector
                if (!deviceDetector) {
                    deviceDetector = new DeviceDetector();
                }
                this.deviceInfo = deviceDetector.getInfo();

                // State
                this.polygons = [];
                this.selectedPolygon = null;
                this.selectedVertex = null;
                this.currentTool = 'select';
                this.gridSize = 20;
                this.gridSnap = true;
                this.zoom = 1;
                this.pan = { x: 0, y: 0 };
                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = null;
                this.potentialDragStart = null; // Store initial click for drag threshold detection
                this.dragThreshold = 3; // Pixels to move before starting drag
                this.panStartPos = null; // Track initial click position for pan detection
                this.panThreshold = 5; // Minimum pixels to move before starting pan
                this.history = [];
                this.historyIndex = -1;
                this.visualizers = new Set();
                this.colors = [
                    '#667eea', '#f56565', '#48bb78', '#ed8936', '#9f7aea',
                    '#38b2ac', '#f687b3', '#4299e1', '#ecc94b', '#a0aec0'
                ];
                this.currentColor = '#667eea';

                // Combine Tool State
                this.combineMode = false;
                this.combineSelection = new Set();
                // For cycling through overlapping polygons in combine mode
                this.combineLastClickPos = null;
                this.combineLastClickTime = 0;
                this.combineCycleIndex = 0;

                // Split Tool State
                this.splitMode = false;
                this.splitStep = 0; // 0: Select Polygon, 1: Draw Line
                this.splitLineStart = null;
                this.splitLineEnd = null;
                this.splitLineType = 'free'; // 'free', 'horizontal', 'vertical'

                // Professional Slice Visual State
                this.sliceAnimationPhase = 0; // For animated effects
                this.sliceLastValidState = false; // Track validity changes
                this.sliceGlowIntensity = 0; // Animated glow
                this.sliceStartTime = 0; // When slice began (for animations)
                this.splitPreviewRenderPending = false; // RAF gate for split preview renders
                this.splitValidityCache = { key: '', value: false, ts: 0 }; // Cache expensive validity checks
                this.splitLastPointerScreen = null; // Last known pointer location for fast-release accuracy
                this.splitGestureStartScreen = null; // Screen-space gesture start for flick detection
                this.splitGestureStartTime = 0; // Gesture start timestamp for flick detection
                this.splitLastReleaseWasFlick = false; // Used by executeSplit guards
                this.splitLastHintTime = 0; // Throttle "slow drag" hint toasts
                this.splitEditingEndpoint = null; // 'start' | 'end' while adjusting a completed line

                // Mouse tracking
                this.mousePos = { x: 0, y: 0 };
                this.mouseWorldPos = { x: 0, y: 0 };

                // Shape menu state
                this.shapeMenuOpen = false;
                this.currentMenuIndex = -1;
                this.lastUsedShape = localStorage.getItem('lastUsedShape') || 'triangle';
                this.lastShapeCreationTime = 0; // Debounce for shape creation

                // Telemetry callbacks
                this.telemetry = {
                    onShapeMenuOpen: null,
                    onShapeMenuClose: null,
                    onShapeSelect: null
                };

                // Panel resizing state
                this.isResizing = false;
                this.activeDivider = null;
                this.startY = 0;
                this.startHeight = 0;
                this.originalHeights = [];

                // Touch/pinch state
                this.isPinching = false;
                this.pinchDistance = 0;
                this.pinchZoom = 1;
                this.touchStartTime = null;
                this.lastTouchTime = 0; // Track last touch to prevent mouse event conflicts
                this.touchStartPos = null; // Store initial touch position for tap detection
                this.touchTapThreshold = 10; // Pixels to move before considering it a drag
                this.touchPanThreshold = 15; // Pixels to move before starting pan (higher for touch)
                this.touchDragThreshold = 8; // Pixels to move before starting drag
                this.touchGestureLocked = false; // Lock gesture type once determined
                this.touchLastMoveTime = 0; // Track movement timing for velocity
                this.touchVelocity = { x: 0, y: 0 }; // Track touch velocity
                this.lastDimensions = null; // Track dimensions for resize compensation
                this.isResizingCanvas = false; // Flag to track intentional resize operations

                // Grid optimization state
                this.gridCache = null;
                this.lastGridState = null; // Track grid state to avoid unnecessary redraws
                this.gridViewBounds = null; // Cache view bounds for grid
                this.gridNeedsRedraw = true; // Flag to track if grid needs redraw
                this.renderScheduled = false; // Throttle render calls
                this.lastRenderTime = 0;
                this.renderThrottleMs = 16; // ~60fps max render rate
                this.renderAnimationFrameId = null; // Track RAF for cleanup
                this.panAnimationFrameId = null; // Smooth pan animation frame

                this.init();
            }

            setTelemetryCallbacks(callbacks) {
                this.telemetry = { ...this.telemetry, ...callbacks };
            }

            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.setupToolbar();
                this.setupColorPicker();
                this.setupResizablePanels();
                this.setupBottomPanel();
                this.setupShapeMenu();
                this.setupResponsiveHandlers();

                // Ensure layout is settled before creating polygon so it is perfectly centered
                // Use multiple RAF calls to ensure canvas is fully sized and ready
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        // First, ensure canvas is properly sized
                        this.syncResize(false); // Don't compensate pan on initial resize
                        requestAnimationFrame(() => {
                            // Now create the polygon and render
                            // Now create the polygon and render (only if empty, to prevent duplication with game loader)
                            if (this.polygons.length === 0) {
                                this.createSamplePolygon();
                            }
                            // Force a render to ensure everything is visible
                            this.render(true);
                        });
                    });
                });

                // Tutorial is now handled by js/tutorial.js via BeginnerMode.start()
            }

            setupResponsiveHandlers() {
                // Debounced resize handler to prevent excessive calls
                let resizeTimeout;
                const handleResize = () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.handleViewportChange();
                        this.resizeCanvas();
                    }, 150); // Debounce resize operations
                };

                // Handle device resize (from DeviceDetector)
                window.addEventListener('deviceResize', (e) => {
                    this.deviceInfo = e.detail;
                    handleResize();
                });

                // Handle orientation change
                window.addEventListener('deviceOrientationChange', (e) => {
                    this.deviceInfo = e.detail;
                    // Use longer timeout for orientation change to ensure layout is stable
                    setTimeout(() => {
                        this.handleViewportChange();
                        this.resizeCanvas();
                    }, 200);
                });

                // Handle window resize (consolidated handler)
                window.addEventListener('resize', handleResize);

                // Initial viewport setup
                this.handleViewportChange();
            }

            handleViewportChange() {
                // Update sidebar visibility based on device type
                if (this.deviceInfo.isMobile || window.innerWidth <= 768) {
                    // Mobile: sidebars are overlays that start closed
                    document.querySelectorAll('.sidebar').forEach(sidebar => {
                        sidebar.classList.remove('mobile-open');
                    });
                    // Hide backdrop
                    const backdrop = document.getElementById('sidebarBackdrop');
                    if (backdrop) {
                        backdrop.classList.remove('active');
                    }
                } else if (this.deviceInfo.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024)) {
                    // Tablet: sidebars are visible by default (like desktop)
                    // Remove mobile-open class to make them visible in normal position
                    document.querySelectorAll('.sidebar').forEach(sidebar => {
                        sidebar.classList.remove('mobile-open');
                    });
                    // Hide backdrop (sidebars are visible, not overlays)
                    const backdrop = document.getElementById('sidebarBackdrop');
                    if (backdrop) {
                        backdrop.classList.remove('active');
                    }
                } else {
                    // Desktop: sidebars are always visible (not overlays)
                    document.querySelectorAll('.sidebar').forEach(sidebar => {
                        sidebar.classList.remove('mobile-open');
                    });
                    const backdrop = document.getElementById('sidebarBackdrop');
                    if (backdrop) {
                        backdrop.classList.remove('active');
                    }
                }

                // Adjust toolbar for mobile/tablet
                const toolbar = document.querySelector('.toolbar');
                if (toolbar && (this.deviceInfo.isMobile || this.deviceInfo.isTablet || window.innerWidth <= 1024)) {
                    toolbar.scrollLeft = 0; // Reset scroll on mobile/tablet
                }

                // Ensure canvas is properly sized
                this.resizeCanvas();

                // If in game mode, re-fit the view to the current polygon for a perfect AAA experience
                // This ensures that when rotating a device or resizing the window, the game content remains perfectly adapted
                if (this.isGameModeActive() && this.polygons.length > 0) {
                    const target = this.selectedPolygon || (this.polygons.length > 0 ? this.polygons[0] : null);
                    if (target) {
                        // Wait for resizeCanvas and layout to settle using nested RAFs
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                this.fitViewToPolygon(target, 0.25); // 25% padding for AAA feel
                            });
                        });
                    }
                }
            }

            setupResizablePanels() {
                const divider1 = document.getElementById('divider1');
                const layersPanel = document.getElementById('layersPanel');
                const colorPanel = document.getElementById('colorPanel');

                // Set initial heights for sidebar panels
                const sidebar = document.querySelector('.sidebar');
                if (!sidebar) return; // Guard clause

                const totalHeight = sidebar.clientHeight;

                // Split 50/50 between Layers and Color since Properties is gone
                const panelHeight = Math.floor(totalHeight * 0.5);

                if (layersPanel) layersPanel.style.height = panelHeight + 'px';
                if (colorPanel) colorPanel.style.height = panelHeight + 'px';

                // Make divider draggable
                if (divider1 && layersPanel && colorPanel) {
                    divider1.addEventListener('mousedown', (e) => {
                        this.isResizing = true;
                        this.activeDivider = divider1;
                        this.startY = e.clientY;
                        this.startHeight = parseInt(window.getComputedStyle(layersPanel).height);

                        document.body.style.cursor = 'row-resize';
                        document.body.style.userSelect = 'none';

                        e.preventDefault();
                    });

                    // Global resize handlers
                    document.addEventListener('mousemove', (e) => {
                        if (!this.isResizing || this.activeDivider !== divider1) return;

                        const deltaY = e.clientY - this.startY;
                        const newHeight1 = Math.max(50, this.startHeight + deltaY);
                        // Adjust second panel to fill remaining space
                        // Note: Flexbox usually handles the fill, but setting specific height might fight it.
                        // Ideally we rely on flex-grow, but since we're using explicit heights:
                        // Let's just update the first panel and let flex take care of the rest or update both.
                        // For simplicity in this existing system, we update both.
                        const sidebarRect = sidebar.getBoundingClientRect();
                        const availableHeight = sidebarRect.height - 12; // divider height
                        const newHeight2 = Math.max(50, availableHeight - newHeight1);

                        layersPanel.style.height = newHeight1 + 'px';
                        colorPanel.style.height = newHeight2 + 'px';

                        this.resizeCanvas();
                    });

                    document.addEventListener('mouseup', () => {
                        if (this.isResizing) {
                            this.isResizing = false;
                            this.activeDivider = null;
                            document.body.style.cursor = '';
                            document.body.style.userSelect = '';
                        }
                    });
                }

            }

            setupBottomPanel() {
                const setupPanel = () => {
                    const panel = document.getElementById('bottomPropertiesPanel');
                    const header = document.querySelector('#bottomPropertiesPanel .bottom-panel-header');
                    const toggleButton = document.getElementById('bottomPanelToggle');

                    if (!panel || !header || !toggleButton) {
                        // Retry if elements not found yet
                        setTimeout(setupPanel, 50);
                        return;
                    }

                    // Helper function to toggle the panel
                    const togglePanel = () => {
                        panel.classList.toggle('collapsed');
                        panel.classList.toggle('expanded');

                        // Animate resize during transition to prevent stretching/squashing
                        const startTime = Date.now();
                        const duration = 350; // Slightly longer than CSS to ensure we catch the end

                        const animateResize = () => {
                            // Synchronous update prevents white flash
                            // Update dimensions immediately
                            this.syncResize(true);
                            // Force redraw immediately
                            this.gridNeedsRedraw = true;
                            this.lastGridState = null;
                            this.render(true);

                            if (Date.now() - startTime < duration) {
                                requestAnimationFrame(animateResize);
                            } else {
                                // Final ensure of text/layout sharpness
                                this.resizeCanvas();
                            }
                        };

                        requestAnimationFrame(animateResize);
                    };

                    // Handle header click first - but ignore clicks on the button
                    header.addEventListener('click', (e) => {
                        // Check if the click originated from the button or its children
                        const clickedButton = e.target.closest('.bottom-panel-toggle') ||
                            e.target.closest('#bottomPanelToggle');
                        if (clickedButton || e.target === toggleButton) {
                            return; // Let button handler deal with it
                        }
                        e.preventDefault();
                        togglePanel();
                    });

                    // Handle button click - stop propagation so header doesn't also trigger
                    toggleButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        togglePanel();
                        return false;
                    });

                    // Also handle clicks on the toggle icon span inside the button
                    const toggleIcon = toggleButton.querySelector('.toggle-icon');
                    if (toggleIcon) {
                        toggleIcon.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            togglePanel();
                            return false;
                        });
                    }
                };

                // Try immediately, then with small delay if needed
                setupPanel();
            }

            setupCanvas() {
                this.resizeCanvas();
                // Note: Resize handler is managed in setupResponsiveHandlers to avoid duplicates
            }

            syncResize(compensatePan = false) {
                const rect = this.container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                // First run initialization or check if update is needed
                if (!this.lastDimensions) {
                    this.lastDimensions = { width: rect.width, height: rect.height };

                    // Initialize canvas size
                    this.canvas.width = rect.width * dpr;
                    this.canvas.height = rect.height * dpr;
                    this.ctx.scale(dpr, dpr);
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                    return true;
                }

                const oldCssHeight = this.lastDimensions.height;
                const newCssHeight = rect.height;
                const oldCssWidth = this.lastDimensions.width;
                const newCssWidth = rect.width;

                // Check if resize is needed (with small threshold for floating point jitter)
                if (Math.abs(oldCssHeight - newCssHeight) < 0.5 && Math.abs(oldCssWidth - newCssWidth) < 0.5) {
                    return false;
                }

                // Update canvas size
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;

                // Scale context to match device pixel ratio
                this.ctx.scale(dpr, dpr);

                // Set CSS size to maintain aspect ratio
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';

                // Adjust pan to maintain the visual position relative to Center.
                // We do NOT want to compensate for height changes by shifting pan.y,
                // because our screenToWorld calculation allows the center to stay fixed naturally
                // if pan is unchanged.
                // (Removed legacy Top-Center compensation logic)

                // Store new dimensions
                this.lastDimensions = { width: rect.width, height: rect.height };
                return true;
            }

            resizeCanvas() {
                // Use requestAnimationFrame for smooth resizing
                requestAnimationFrame(() => {
                    // This is an intentional resize, so compensate pan
                    const didResize = this.syncResize(true);
                    // Mark grid for redraw on resize
                    this.gridNeedsRedraw = true;
                    this.lastGridState = null;
                    // Only render if resize actually happened
                    if (didResize) {
                        this.render();
                    }
                });
            }

            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                // Global mouse listeners keep split drag responsive even if pointer leaves canvas
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
                this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));

                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));

                // Keyboard events
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));

                // UI events
                document.getElementById('zoomIn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoomOut').addEventListener('click', () => this.zoomOut());
                document.getElementById('zoomReset')?.addEventListener('click', () => this.zoomReset());
                document.getElementById('panUp')?.addEventListener('click', () => this.panByDirection('up'));
                document.getElementById('panDown')?.addEventListener('click', () => this.panByDirection('down'));
                document.getElementById('panLeft')?.addEventListener('click', () => this.panByDirection('left'));
                document.getElementById('panRight')?.addEventListener('click', () => this.panByDirection('right'));
                document.getElementById('fullscreenToggle').addEventListener('click', () => this.toggleFullscreen());

                // Fullscreen change event listeners (with browser prefixes)
                document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('mozfullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('MSFullscreenChange', () => this.handleFullscreenChange());

                const gridSnapToggle = document.getElementById('gridSnapToggle');
                if (gridSnapToggle) {
                    gridSnapToggle.checked = !!this.gridSnap;
                    gridSnapToggle.addEventListener('change', () => {
                        this.gridSnap = !!gridSnapToggle.checked;
                        this.updateGridSnapControlLabel();
                        this.render(true);
                    });
                }
                this.updateGridSnapControlLabel();

                // Visualizer toggles
                document.querySelectorAll('[data-viz]').forEach(item => {
                    item.addEventListener('click', () => {
                        const viz = item.dataset.viz;
                        if (this.visualizers.has(viz)) {
                            this.visualizers.delete(viz);
                            item.classList.remove('active');
                        } else {
                            this.visualizers.add(viz);
                            item.classList.add('active');
                        }
                        this.render(true); // Force render when toggling visualizers
                    });
                });
            }

            setupToolbar() {
                const tools = document.querySelectorAll('[data-tool]');
                tools.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tool = btn.dataset.tool;

                        if (tool === 'undo') {
                            this.undo();
                        } else if (tool === 'redo') {
                            this.redo();
                        } else if (tool === 'save') {
                            this.save();
                        } else if (tool === 'load') {
                            this.load();
                        } else if (tool === 'reset') {
                            this.reset();
                        } else if (tool === 'combine') {
                            this.handleCombineToolClick();
                        } else if (tool === 'split') {
                            this.handleSplitToolClick();
                        } else {
                            // Tool selection
                            if (this.combineMode && tool !== 'combine') {
                                this.exitCombineMode();
                            }
                            if (this.splitMode && tool !== 'split') {
                                this.exitSplitMode();
                            }
                            tools.forEach(t => t.classList.remove('active'));
                            btn.classList.add('active');
                            this.currentTool = tool;
                            this.updateCursor();
                        }
                    });
                });

                // Setup Cancel Combine Button
                const cancelBtn = document.getElementById('cancelCombineBtn');
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        this.exitCombineMode();
                        this.setTool('select');
                    });
                }

                // Setup Cancel Split Button
                const cancelSplitBtn = document.getElementById('cancelSplitBtn');
                if (cancelSplitBtn) {
                    cancelSplitBtn.addEventListener('click', () => {
                        this.exitSplitMode();
                        this.setTool('select');
                    });
                }

                // Setup Split Confirmation Modal Buttons
                const splitConfirmBtn = document.getElementById('splitConfirmSelectionBtnModal');
                if (splitConfirmBtn) {
                    splitConfirmBtn.addEventListener('click', () => {
                        const confirmModal = document.getElementById('splitConfirmSelectionModal');
                        if (confirmModal) confirmModal.style.display = 'none';

                        // Execute split setup
                        this.splitStep = 1; // Move to line drawing
                        this.updateSplitLineConstraint(this.selectedPolygon.getCenter()); // Init
                        this.render();
                    });
                }

                // Setup Reset Modal Buttons
                const resetModal = document.getElementById('resetModal');
                const confirmResetBtn = document.getElementById('confirmResetBtn');
                const cancelResetBtn = document.getElementById('cancelResetBtn');

                if (confirmResetBtn) {
                    confirmResetBtn.addEventListener('click', () => {
                        this.executeReset();
                        resetModal.style.display = 'none';
                    });
                }

                if (cancelResetBtn) {
                    cancelResetBtn.addEventListener('click', () => {
                        resetModal.style.display = 'none';
                    });
                }

                // Close reset modal on outside click
                if (resetModal) {
                    resetModal.addEventListener('click', (e) => {
                        if (e.target === resetModal) {
                            resetModal.style.display = 'none';
                        }
                    });
                }

                // Setup Split Confirmation Modal Buttons
                const confirmModal = document.getElementById('splitConfirmSelectionModal');
                const cancelSelBtn = document.getElementById('splitCancelSelectionBtn');
                const confirmSelBtn = document.getElementById('splitConfirmSelectionBtnModal');

                if (cancelSelBtn) {
                    cancelSelBtn.onclick = () => {
                        confirmModal.style.display = 'none';
                        this.selectedPolygon = null;
                        this.render();
                    };
                }

                if (confirmSelBtn) {
                    confirmSelBtn.onclick = () => {
                        confirmModal.style.display = 'none';
                        this.splitStep = 1; // Move to drawing line phase
                        this.updateSplitPrompt("Step 2: Draw a line across the polygon to split it.");
                        this.render();
                    };
                }
            }

            setupColorPicker() {
                const colorBtn = document.getElementById('toolbarColorBtn');
                const colorInput = document.getElementById('toolbarColorInput');

                if (colorBtn && colorInput) {
                    // Sync button color with current selection
                    const updateButtonColor = (color) => {
                        colorBtn.style.color = color;
                        // Optional: Add a small indicator or border
                        colorBtn.style.borderBottom = `3px solid ${color}`;
                    };

                    updateButtonColor(this.currentColor);

                    // When button is clicked, trigger the hidden color input
                    colorBtn.addEventListener('click', () => {
                        colorInput.click();
                    });

                    // Handle color change
                    colorInput.addEventListener('input', (e) => {
                        const color = e.target.value;
                        this.currentColor = color;
                        updateButtonColor(color);

                        if (this.selectedPolygon) {
                            this.selectedPolygon.color = color;
                            this.saveHistory();
                            this.render();
                            this.updateLayers(); // To update the color indicator in layers
                        }
                    });

                    // Also handle direct confirmation (change event)
                    colorInput.addEventListener('change', (e) => {
                        this.saveHistory(); // Ensure history is saved on final selection
                    });
                }
            }

            setupShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                const createPolygonBtn = document.getElementById('createPolygonBtn');
                const toolbarCreateBtn = document.getElementById('toolbarCreateBtn');
                const closeBtn = document.getElementById('closeCreateShapeModal');

                // Open Modal
                const openMenu = () => this.openShapeMenu();
                if (createPolygonBtn) createPolygonBtn.addEventListener('click', openMenu);
                if (toolbarCreateBtn) toolbarCreateBtn.addEventListener('click', openMenu);

                // Close Modal with X button
                closeBtn.addEventListener('click', () => {
                    this.closeShapeMenu();
                });

                // Close Modal when clicking outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closeShapeMenu();
                    }
                });

                // Handle shape selection
                document.querySelectorAll('.shape-option-card').forEach(option => {
                    option.addEventListener('click', (e) => {
                        this.selectShape(e.currentTarget);
                    });
                });
            }

            toggleShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                if (modal.style.display === 'flex') {
                    this.closeShapeMenu();
                } else {
                    this.openShapeMenu();
                }
            }

            openShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                modal.style.display = 'flex';
                this.shapeMenuOpen = true;

                if (this.telemetry.onShapeMenuOpen) {
                    this.telemetry.onShapeMenuOpen();
                }
            }

            closeShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                modal.style.display = 'none';
                this.shapeMenuOpen = false;

                if (this.telemetry.onShapeMenuClose) {
                    this.telemetry.onShapeMenuClose();
                }
            }

            selectShape(option) {
                // simple debounce to prevent double-click creation
                const now = Date.now();
                if (now - this.lastShapeCreationTime < 500) return;
                this.lastShapeCreationTime = now;

                const shapeType = option.dataset.shape;
                const sides = parseInt(option.dataset.sides);

                // Get the center of the current viewport, snapped to grid
                const viewportCenter = this.getViewportCenter();
                const centerX = viewportCenter.x;
                const centerY = viewportCenter.y;

                // Create polygon based on shape type, centered on viewport
                let vertices;
                switch (shapeType) {
                    case 'triangle':
                        // Equilateral triangle, 60 units per side (snapped to grid)
                        const triSize = Math.round(60 / this.gridSize) * this.gridSize;
                        vertices = [
                            { x: centerX, y: centerY - triSize * 0.577 }, // Top vertex
                            { x: centerX - triSize * 0.5, y: centerY + triSize * 0.289 }, // Bottom left
                            { x: centerX + triSize * 0.5, y: centerY + triSize * 0.289 }  // Bottom right
                        ];
                        break;
                    case 'square':
                        // Square, 60 units per side (snapped to grid)
                        const squareSize = Math.round(60 / this.gridSize) * this.gridSize;
                        const halfSize = squareSize / 2;
                        vertices = [
                            { x: centerX - halfSize, y: centerY - halfSize },
                            { x: centerX + halfSize, y: centerY - halfSize },
                            { x: centerX + halfSize, y: centerY + halfSize },
                            { x: centerX - halfSize, y: centerY + halfSize }
                        ];
                        break;
                    case 'rectangle':
                        // Rectangle, 80x60 units (snapped to grid)
                        const rectWidth = Math.round(80 / this.gridSize) * this.gridSize;
                        const rectHeight = Math.round(60 / this.gridSize) * this.gridSize;
                        const halfWidth = rectWidth / 2;
                        const halfHeight = rectHeight / 2;
                        vertices = [
                            { x: centerX - halfWidth, y: centerY - halfHeight },
                            { x: centerX + halfWidth, y: centerY - halfHeight },
                            { x: centerX + halfWidth, y: centerY + halfHeight },
                            { x: centerX - halfWidth, y: centerY + halfHeight }
                        ];
                        break;
                    case 'pentagon':
                        vertices = this.createRegularPolygon(5, 50, centerX, centerY);
                        break;
                    case 'hexagon':
                        vertices = this.createRegularPolygon(6, 40, centerX, centerY);
                        break;
                    case 'heptagon':
                        vertices = this.createRegularPolygon(7, 35, centerX, centerY);
                        break;
                    case 'octagon':
                        vertices = this.createRegularPolygon(8, 30, centerX, centerY);
                        break;
                    default:
                        // Default to triangle
                        const defaultSize = Math.round(60 / this.gridSize) * this.gridSize;
                        vertices = [
                            { x: centerX, y: centerY - defaultSize * 0.577 },
                            { x: centerX - defaultSize * 0.5, y: centerY + defaultSize * 0.289 },
                            { x: centerX + defaultSize * 0.5, y: centerY + defaultSize * 0.289 }
                        ];
                }

                // Snap all vertices to grid to ensure perfect grid alignment
                vertices = vertices.map(v => this.snapToGrid(v));

                const polygon = new Polygon(vertices, this.currentColor);
                polygon.name = `${shapeType.charAt(0).toUpperCase() + shapeType.slice(1)} ${this.polygons.length + 1}`;
                this.polygons.push(polygon);
                this.selectedPolygon = polygon;
                this.saveHistory();
                this.updateProperties();
                this.updateLayers();
                this.render();

                this.closeShapeMenu();

                if (this.telemetry.onShapeSelect) {
                    this.telemetry.onShapeSelect({
                        type: shapeType,
                        sides: sides,
                        polygon: polygon
                    });
                }

                // Store last used shape
                localStorage.setItem('lastUsedShape', shapeType);
            }

            createRegularPolygon(sides, radius, centerX, centerY) {
                // Snap center to grid
                const snappedCenter = this.snapToGrid({ x: centerX, y: centerY });
                centerX = snappedCenter.x;
                centerY = snappedCenter.y;

                // Snap radius to grid for better alignment
                radius = Math.round(radius / this.gridSize) * this.gridSize;

                const vertices = [];
                const angleStep = (Math.PI * 2) / sides;

                for (let i = 0; i < sides; i++) {
                    const angle = i * angleStep - Math.PI / 2; // Start from top
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);

                    // Snap each vertex to grid for perfect alignment
                    vertices.push(this.snapToGrid({ x, y }));
                }

                return vertices;
            }

            // Calculate the centroid (geometric center) of a polygon
            getPolygonCenter(polygon) {
                if (!polygon || !polygon.vertices || polygon.vertices.length === 0) {
                    return { x: 0, y: 0 };
                }
                const sum = polygon.vertices.reduce((acc, v) => ({ x: acc.x + v.x, y: acc.y + v.y }), { x: 0, y: 0 });
                return {
                    x: sum.x / polygon.vertices.length,
                    y: sum.y / polygon.vertices.length
                };
            }

            // Center the view on a specific world coordinate
            centerViewOn(worldX, worldY) {
                // To center world point (worldX, worldY) at viewport center:
                // Viewport center in world coords = screenToWorld(cssWidth/2, cssHeight/2)
                // We want: screenToWorld(cssWidth/2, cssHeight/2) = (worldX, worldY)
                // From screenToWorld: (cssWidth/2 - cssWidth/2 - pan.x) / zoom = worldX
                // So: -pan.x / zoom = worldX
                // Therefore: pan.x = -worldX * zoom
                // Similarly: pan.y = -worldY * zoom
                const rect = this.canvas.getBoundingClientRect();
                const cssWidth = rect.width;
                const cssHeight = rect.height;

                // Calculate pan needed to center the world point at viewport center
                this.pan.x = -worldX * this.zoom;
                this.pan.y = -worldY * this.zoom;
            }

            // Fit the view to contain a specific polygon
            fitViewToPolygon(polygon, paddingPercent = 0.2) {
                if (!polygon || !polygon.vertices || polygon.vertices.length === 0) return;

                // Calculate bounding box
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                for (const v of polygon.vertices) {
                    minX = Math.min(minX, v.x);
                    maxX = Math.max(maxX, v.x);
                    minY = Math.min(minY, v.y);
                    maxY = Math.max(maxY, v.y);
                }

                const polyWidth = maxX - minX;
                const polyHeight = maxY - minY;
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                // Get viewport dimensions
                const rect = this.canvas.getBoundingClientRect();
                const cssWidth = rect.width;
                const cssHeight = rect.height;

                // Calculate zoom needed to fit
                // Available space is (1 - padding * 2)
                const availableWidth = cssWidth * (1 - paddingPercent * 2);
                const availableHeight = cssHeight * (1 - paddingPercent * 2);

                const zoomX = availableWidth / (polyWidth || 1);
                const zoomY = availableHeight / (polyHeight || 1);

                // Restrict zoom to reasonable limits (e.g. don't zoom in infinitely for a dot)
                let newZoom = Math.min(zoomX, zoomY);
                newZoom = Math.min(2.5, Math.max(0.5, newZoom)); // Clamp zoom to keep it looking good

                this.zoom = newZoom;
                this.centerViewOn(centerX, centerY);
                this.gridNeedsRedraw = true;
                this.lastGridState = null;
                this.render();
            }

            isGameModeActive() {
                const isGameActive = window.game && window.game.state === GameState.PLAYING;
                const isFunModeActive = window.game &&
                    window.game.currentMode &&
                    typeof window.game.currentMode.isFunModeActive === 'function' &&
                    window.game.currentMode.isFunModeActive();
                return Boolean(isGameActive || isFunModeActive);
            }

            pruneSamplePolygonForGame() {
                if (!this.isGameModeActive()) {
                    return false;
                }

                const initialCount = this.polygons.length;
                this.polygons = this.polygons.filter(p => p.name !== 'Triangle 1');

                if (this.selectedPolygon && this.selectedPolygon.name === 'Triangle 1') {
                    this.selectedPolygon = null;
                    this.selectedVertex = null;
                }

                return this.polygons.length !== initialCount;
            }

            createSamplePolygon() {
                if (this.isGameModeActive() || this.polygons.length > 0) {
                    return;
                }

                // Reset pan and zoom to ensure consistent initial state
                // World origin (0,0) appears at screen center when pan is (0,0) and zoom is 1
                this.pan = { x: 0, y: 0 };
                this.zoom = 1;

                // Create a triangle at world origin (0,0) snapped to grid
                // The triangle will be centered on the screen since pan is (0,0)
                const centerX = 0;
                const centerY = 0;

                // Equilateral triangle, 60 units per side (snapped to grid)
                const triSize = Math.round(60 / this.gridSize) * this.gridSize;
                const vertices = [
                    { x: centerX, y: centerY - triSize * 0.577 }, // Top vertex
                    { x: centerX - triSize * 0.5, y: centerY + triSize * 0.289 }, // Bottom left
                    { x: centerX + triSize * 0.5, y: centerY + triSize * 0.289 }  // Bottom right
                ].map(v => this.snapToGrid(v));

                const triangle = new Polygon(vertices, this.currentColor);
                triangle.name = 'Triangle 1';
                this.polygons.push(triangle);

                // Select the default polygon so properties are visible immediately
                this.selectedPolygon = triangle;

                // Mark grid for redraw since we changed selection
                this.markGridForRedraw();

                this.saveHistory();
                this.updateProperties();
                this.updateLayers();
            }

            handleCombineToolClick() {
                if (this.combineMode) {
                    // Second click: Execute Combine
                    this.executeCombine();
                } else {
                    // First click: Enter Selection Mode
                    if (localStorage.getItem('hideCombineWarning') === 'true') {
                        this.enterCombineMode();
                    } else {
                        this.showCombineModal();
                    }
                }
            }

            showCombineModal() {
                const modal = document.getElementById('combineModal');
                const continueBtn = document.getElementById('combineContinueBtn');
                const checkbox = document.getElementById('combineDontShowAgain');

                modal.style.display = 'flex';

                // One-time listener setup (or remove old ones to be safe, but simple is ok here)
                continueBtn.onclick = () => {
                    if (checkbox.checked) {
                        localStorage.setItem('hideCombineWarning', 'true');
                    }
                    modal.style.display = 'none';
                    this.enterCombineMode();
                };

                // Close on outside click? Maybe not for this specific modal flow.
            }

            enterCombineMode() {
                this.combineMode = true;
                this.combineSelection.clear();
                // Reset cycling state for fresh start
                this.combineLastClickPos = null;
                this.combineLastClickTime = 0;
                this.combineCycleIndex = 0;
                this.setTool('combine'); // Visual update for button

                // Update button text or style to indicate "Execute"
                const btn = document.querySelector('[data-tool="combine"]');
                if (btn) {
                    btn.textContent = 'Execute Combine';
                    btn.classList.add('active');
                    btn.style.background = 'linear-gradient(135deg, #f6ad55 0%, #ed8936 100%)';
                    btn.style.color = 'white';
                }

                // Show Cancel button
                const cancelBtn = document.getElementById('cancelCombineBtn');
                if (cancelBtn) {
                    cancelBtn.style.display = 'flex';
                }

                this.selectedPolygon = null;
                this.selectedVertex = null;
                this.render();
            }

            exitCombineMode() {
                this.combineMode = false;
                this.combineSelection.clear();

                const btn = document.querySelector('[data-tool="combine"]');
                if (btn) {
                    btn.textContent = 'Combine';
                    btn.classList.remove('active');
                    btn.style.background = '';
                    btn.style.color = '';
                }

                // Hide Cancel button
                const cancelBtn = document.getElementById('cancelCombineBtn');
                if (cancelBtn) {
                    cancelBtn.style.display = 'none';
                }

                this.render();
            }

            executeCombine() {
                if (this.combineSelection.size < 2) {
                    const errorModal = document.getElementById('combineSelectionModal');
                    if (errorModal) {
                        errorModal.style.display = 'flex';
                    }
                    return;
                }

                const polygonsToCombine = Array.from(this.combineSelection);

                // Validate that all polygons to combine still exist in the main array
                const validPolygons = polygonsToCombine.filter(p => this.polygons.includes(p));
                if (validPolygons.length !== polygonsToCombine.length) {
                    console.warn('Some polygons to combine are no longer in the array');
                    alert('Error: Some selected polygons are no longer available. Please try again.');
                    this.exitCombineMode();
                    return;
                }

                // CRITICAL SAFETY: Deep clone the ENTIRE state before ANY operation
                // This allows complete restoration if anything goes wrong
                const stateBackup = {
                    polygons: this.polygons.map(p => ({
                        vertices: p.vertices.map(v => ({ x: v.x, y: v.y })),
                        color: p.color,
                        name: p.name,
                        visible: p.visible
                    })),
                    selectedPolygonName: this.selectedPolygon ? this.selectedPolygon.name : null,
                    combineSelectionNames: polygonsToCombine.map(p => p.name)
                };

                try {
                    // STEP 1: Try to compute union
                    let unionResultVertices = null;
                    let unionError = null;

                    try {
                        unionResultVertices = Geometry.union(polygonsToCombine);
                    } catch (e) {
                        unionError = e;
                        console.error('Union computation error:', e);
                    }

                    // STEP 2: Validate union result
                    const isValidUnion = unionResultVertices &&
                        Array.isArray(unionResultVertices) &&
                        unionResultVertices.length >= 3 &&
                        unionResultVertices.every(v =>
                            v &&
                            typeof v.x === 'number' &&
                            typeof v.y === 'number' &&
                            isFinite(v.x) &&
                            isFinite(v.y)
                        );

                    if (!isValidUnion) {
                        // Union failed - try convex hull fallback for overlapping polygons
                        console.warn('Standard union failed, trying convex hull fallback');

                        // Collect all vertices from all polygons to combine
                        const allVertices = [];
                        for (const poly of polygonsToCombine) {
                            for (const v of poly.vertices) {
                                allVertices.push({ x: v.x, y: v.y });
                            }
                        }

                        // Check if polygons actually overlap or touch
                        let polygonsOverlap = false;
                        outer: for (let i = 0; i < polygonsToCombine.length; i++) {
                            for (let j = i + 1; j < polygonsToCombine.length; j++) {
                                const polyA = polygonsToCombine[i];
                                const polyB = polygonsToCombine[j];
                                // Check if any vertex of one is inside the other
                                for (const v of polyA.vertices) {
                                    if (polyB.containsPoint(v)) {
                                        polygonsOverlap = true;
                                        break outer;
                                    }
                                }
                                for (const v of polyB.vertices) {
                                    if (polyA.containsPoint(v)) {
                                        polygonsOverlap = true;
                                        break outer;
                                    }
                                }
                                // Check for edge intersections
                                for (let a = 0; a < polyA.vertices.length; a++) {
                                    const a1 = polyA.vertices[a];
                                    const a2 = polyA.vertices[(a + 1) % polyA.vertices.length];
                                    for (let b = 0; b < polyB.vertices.length; b++) {
                                        const b1 = polyB.vertices[b];
                                        const b2 = polyB.vertices[(b + 1) % polyB.vertices.length];
                                        if (this.segmentsIntersect(a1, a2, b1, b2)) {
                                            polygonsOverlap = true;
                                            break outer;
                                        }
                                    }
                                }
                            }
                        }

                        if (!polygonsOverlap) {
                            // Polygons don't overlap - can't combine
                            if (unionError) {
                                alert('Error combining polygons: ' + (unionError.message || unionError.toString()));
                            } else {
                                alert('Could not combine polygons. Ensure they overlap or touch to form a valid shape.');
                            }
                            return; // Early return - no state was modified
                        }

                        // Create convex hull as fallback
                        unionResultVertices = this.computeConvexHull(allVertices);

                        if (!unionResultVertices || unionResultVertices.length < 3) {
                            alert('Could not combine polygons. The union operation failed.');
                            return; // Early return - no state was modified
                        }

                        console.log('Using convex hull fallback for combine');
                    }

                    // STEP 3: Validate polygon area
                    const area = Math.abs(Geometry.getArea(unionResultVertices));
                    if (!isFinite(area) || area < 1e-6) {
                        console.warn('Combined polygon would be degenerate', { area });
                        alert('Combined polygon would be too small or invalid.');
                        return; // Early return - no state was modified
                    }

                    // STEP 4: Create new polygon
                    const newPoly = new Polygon(unionResultVertices, this.currentColor);
                    newPoly.name = 'Combined Polygon ' + (this.polygons.length + 1);

                    if (!newPoly.vertices || newPoly.vertices.length < 3) {
                        console.error('New polygon creation failed');
                        alert('Error: Could not create combined polygon.');
                        return; // Early return - no state was modified
                    }

                    // STEP 5: NOW save history - we're about to modify state
                    // This saves the CURRENT state (before combine) for undo to return to
                    this.saveHistory();

                    // STEP 6: Modify state atomically
                    const polygonsToRemove = new Set(this.combineSelection);
                    const originalLength = this.polygons.length;
                    this.polygons = this.polygons.filter(p => !polygonsToRemove.has(p));
                    this.polygons.push(newPoly);

                    // STEP 7: Verify modification was correct
                    const expectedLength = originalLength - polygonsToRemove.size + 1;
                    if (this.polygons.length !== expectedLength) {
                        throw new Error(`Polygon count mismatch after combine: expected ${expectedLength}, got ${this.polygons.length}`);
                    }

                    // STEP 8: Save new state for redo functionality
                    // This saves the COMBINED result so redo can restore it
                    this.saveHistory();

                    // STEP 9: Update UI
                    this.selectedPolygon = newPoly;
                    this.updateProperties();
                    this.updateLayers();
                    this.exitCombineMode();
                    this.setTool('select');
                    this.render();

                    console.log('Combine successful', {
                        removedCount: polygonsToRemove.size,
                        newPolygonVertices: newPoly.vertices.length,
                        totalPolygons: this.polygons.length
                    });

                } catch (e) {
                    console.error('Critical error in executeCombine:', e);

                    // CRITICAL: Restore state from backup
                    console.log('Restoring state from backup...');
                    this.polygons = stateBackup.polygons.map(p => {
                        const poly = new Polygon(p.vertices, p.color);
                        poly.name = p.name;
                        poly.visible = p.visible;
                        return poly;
                    });

                    // Try to restore selection
                    if (stateBackup.selectedPolygonName) {
                        this.selectedPolygon = this.polygons.find(p => p.name === stateBackup.selectedPolygonName) || null;
                    } else {
                        this.selectedPolygon = null;
                    }

                    this.updateProperties();
                    this.updateLayers();
                    this.render();

                    alert('Error combining polygons. Your original shapes have been restored.');
                }
            }

            // Helper: Check if two line segments intersect
            segmentsIntersect(p1, p2, p3, p4) {
                const d1 = this.direction(p3, p4, p1);
                const d2 = this.direction(p3, p4, p2);
                const d3 = this.direction(p1, p2, p3);
                const d4 = this.direction(p1, p2, p4);

                if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
                    ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
                    return true;
                }

                const eps = 1e-9;
                if (Math.abs(d1) < eps && this.onSegment(p3, p4, p1)) return true;
                if (Math.abs(d2) < eps && this.onSegment(p3, p4, p2)) return true;
                if (Math.abs(d3) < eps && this.onSegment(p1, p2, p3)) return true;
                if (Math.abs(d4) < eps && this.onSegment(p1, p2, p4)) return true;

                return false;
            }

            direction(a, b, c) {
                return (c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y);
            }

            onSegment(a, b, c) {
                return c.x >= Math.min(a.x, b.x) - 1e-9 && c.x <= Math.max(a.x, b.x) + 1e-9 &&
                    c.y >= Math.min(a.y, b.y) - 1e-9 && c.y <= Math.max(a.y, b.y) + 1e-9;
            }

            // Helper: Compute convex hull using Graham scan
            computeConvexHull(points) {
                if (!points || points.length < 3) return null;

                // Remove duplicates
                const unique = [];
                const seen = new Set();
                for (const p of points) {
                    const key = `${Math.round(p.x * 1000)},${Math.round(p.y * 1000)}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        unique.push({ x: p.x, y: p.y });
                    }
                }

                if (unique.length < 3) return null;

                // Find bottom-most point (or left-most in case of tie)
                let start = 0;
                for (let i = 1; i < unique.length; i++) {
                    if (unique[i].y < unique[start].y ||
                        (unique[i].y === unique[start].y && unique[i].x < unique[start].x)) {
                        start = i;
                    }
                }

                const pivot = unique[start];

                // Sort by polar angle
                const sorted = unique.filter((_, i) => i !== start).sort((a, b) => {
                    const angleA = Math.atan2(a.y - pivot.y, a.x - pivot.x);
                    const angleB = Math.atan2(b.y - pivot.y, b.x - pivot.x);
                    if (Math.abs(angleA - angleB) < 1e-9) {
                        const distA = (a.x - pivot.x) ** 2 + (a.y - pivot.y) ** 2;
                        const distB = (b.x - pivot.x) ** 2 + (b.y - pivot.y) ** 2;
                        return distA - distB;
                    }
                    return angleA - angleB;
                });

                const hull = [{ x: pivot.x, y: pivot.y }];
                for (const p of sorted) {
                    while (hull.length > 1) {
                        const a = hull[hull.length - 2];
                        const b = hull[hull.length - 1];
                        const cross = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);
                        if (cross <= 0) break;
                        hull.pop();
                    }
                    hull.push({ x: p.x, y: p.y });
                }

                return hull.length >= 3 ? hull : null;
            }

            // Helper function to restore polygons from backup
            restorePolygonsFromBackup(backup) {
                this.polygons = backup.map(p => {
                    const poly = new Polygon(p.vertices, p.color);
                    poly.name = p.name;
                    poly.visible = p.visible;
                    return poly;
                });
                this.render();
            }

            handleSplitToolClick() {
                if (this.splitMode) {
                    // Second click: Execute Split
                    this.executeSplit();
                } else {
                    // First click: Enter Split Mode
                    if (localStorage.getItem('hideSplitWarning') === 'true') {
                        this.enterSplitMode();
                    } else {
                        this.showSplitModal();
                    }
                }
            }

            showSplitModal() {
                const modal = document.getElementById('splitModal');
                const continueBtn = document.getElementById('splitContinueBtn');
                const checkbox = document.getElementById('splitDontShowAgain');

                modal.style.display = 'flex';

                // One-time listener setup
                continueBtn.onclick = () => {
                    if (checkbox.checked) {
                        localStorage.setItem('hideSplitWarning', 'true');
                    }
                    modal.style.display = 'none';
                    this.enterSplitMode();
                };
            }

            enterSplitMode() {
                this.splitMode = true;
                this.splitStep = 1; // 1: Draw Line (Skip selection)
                this.splitLineStart = null;
                this.splitLineEnd = null;
                this.splitLineType = 'free';
                this.setTool('split');
                this.selectedPolygon = null; // Clear selection on entry

                // Update button text
                const btn = document.querySelector('[data-tool="split"]');
                if (btn) {
                    btn.textContent = 'Execute Split';
                    btn.classList.add('active');
                    btn.style.background = 'linear-gradient(135deg, #f6ad55 0%, #ed8936 100%)';
                    btn.style.color = 'white';
                    btn.style.display = 'none'; // Only show when line is ready
                }

                const cancelBtn = document.getElementById('cancelSplitBtn');
                if (cancelBtn) cancelBtn.style.display = 'flex';

                this.updateSplitPrompt("Draw a line across shapes to split them.");
                this.selectedVertex = null;

                // Removed visual controls (Free, Horizontal, etc) as per user request
                // Defaulting to free split which is already set by this.splitLineType = 'free';

                this.render();
            }

            exitSplitMode() {
                this.splitMode = false;
                this.splitStep = 0;
                this.splitLineStart = null;
                this.splitLineEnd = null;

                const btn = document.querySelector('[data-tool="split"]');
                if (btn) {
                    btn.textContent = 'Split';
                    btn.classList.remove('active');
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.style.display = 'flex';
                }

                const confirmBtn = document.getElementById('splitConfirmSelectionBtn');
                if (confirmBtn) confirmBtn.style.display = 'none';

                const cancelBtn = document.getElementById('cancelSplitBtn');
                if (cancelBtn) cancelBtn.style.display = 'none';

                // No longer handling splitControls as they are not created

                const prompt = document.getElementById('splitPrompt');
                if (prompt) prompt.remove();

                this.render();
            }

            updateSplitPrompt(text) {
                let prompt = document.getElementById('splitPrompt');

                if (!text) {
                    if (prompt) prompt.style.display = 'none';
                    return;
                }

                if (!prompt) {
                    prompt = document.createElement('div');
                    prompt.id = 'splitPrompt';
                    prompt.style.cssText = `
                        position: absolute;
                        top: auto;
                        bottom: 110px; /* Moved to bottom to avoid obscuring polygon */
                        left: 50%;
                        transform: translateX(-50%);
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        padding: 10px 20px;
                        border-radius: 20px;
                        font-size: 14px;
                        font-weight: 600;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                        z-index: 1000;
                        pointer-events: none;
                        white-space: nowrap;
                        animation: fadeIn 0.3s ease-out;
                        max-width: 90%;
                        overflow: hidden;
                        text-overflow: ellipsis;
                        text-align: center;
                    `;
                    document.querySelector('.canvas-container').appendChild(prompt);
                } else {
                    prompt.style.display = 'block';
                }
                prompt.textContent = text;
            }

            updateSplitLineConstraint(pos) {
                if (!pos) return;
                if (this.splitLineType === 'horizontal') {
                    this.splitLineEnd = { x: pos.x, y: this.splitLineStart.y };
                } else if (this.splitLineType === 'vertical') {
                    this.splitLineEnd = { x: this.splitLineStart.x, y: pos.y };
                } else {
                    this.splitLineEnd = pos;
                }
            }

            showToast(message, isError = false) {
                let toast = document.getElementById('gameToast');
                if (!toast) {
                    toast = document.createElement('div');
                    toast.id = 'gameToast';
                    toast.style.cssText = `
                         position: fixed;
                         top: 100px;
                         left: 50%;
                         transform: translateX(-50%);
                         background: #333;
                         color: white;
                         padding: 12px 24px;
                         border-radius: 50px;
                         font-family: 'Inter', sans-serif;
                         font-size: 14px;
                         font-weight: 500;
                         z-index: 2000;
                         pointer-events: none;
                         opacity: 0;
                         transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
                         box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
                     `;
                    document.body.appendChild(toast);
                }
                toast.textContent = message;
                toast.style.background = isError ? '#ef4444' : '#1f2937';
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(-50%) translateY(0)';

                if (this.toastTimeout) clearTimeout(this.toastTimeout);
                this.toastTimeout = setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateX(-50%) translateY(-20px)';
                }, 3000);
            }

            findSplitEndpointAt(pos) {
                if (!this.splitLineStart || !this.splitLineEnd) return null;

                const hitRadiusPx = 24;
                const hitRadiusWorld = hitRadiusPx / Math.max(0.1, this.zoom || 1);

                const distToStart = this.distance(pos, this.splitLineStart);
                const distToEnd = this.distance(pos, this.splitLineEnd);

                if (distToStart <= hitRadiusWorld || distToEnd <= hitRadiusWorld) {
                    return distToStart <= distToEnd ? 'start' : 'end';
                }

                return null;
            }

            updateSplitExecuteButtonState() {
                const btn = document.querySelector('[data-tool="split"]');
                if (!btn) return;

                if (!this.splitMode) {
                    btn.style.display = 'flex';
                    return;
                }

                const hasLine = !!(this.splitLineStart && this.splitLineEnd);
                const isValid = hasLine && this.isSplitValid(this.splitLineStart, this.splitLineEnd);

                // Only allow execution for a fully valid (green) line.
                btn.style.display = isValid ? 'flex' : 'none';
            }

            cancelSplitLine() {
                this.splitLineStart = null;
                this.splitLineEnd = null;
                this.splitEditingEndpoint = null;
                this.splitLastReleaseWasFlick = false;
                this.updateSplitExecuteButtonState();
                this.scheduleSplitPreviewRender();
            }

            removeDuplicates() {
                const uniquePolys = [];
                const seenHashes = new Set();
                let dupsFound = 0;

                for (const poly of this.polygons) {
                    if (!poly.vertices || poly.vertices.length === 0) continue;
                    // Hash vertices to detect exact duplicates (phantom parents)
                    const hash = poly.vertices.map(v => `${Math.round(v.x)},${Math.round(v.y)}`).join('|');

                    if (!seenHashes.has(hash)) {
                        seenHashes.add(hash);
                        uniquePolys.push(poly);
                    } else {
                        dupsFound++;
                    }
                }

                if (dupsFound > 0) {
                    console.log(`Auto-removed ${dupsFound} duplicate polygons.`);
                    this.polygons = uniquePolys;
                    this.updateLayers();
                    if (this.selectedPolygon && !this.polygons.includes(this.selectedPolygon)) {
                        this.selectedPolygon = null;
                        this.selectedVertex = null;
                    }
                }
            }

            executeSplit() {
                // 1. Clean Duplicates First (Failsafe)
                this.removeDuplicates();

                if (!this.splitLineStart || !this.splitLineEnd) {
                    this.showToast('Please draw a line to split polygons.', true);
                    return;
                }

                // 2. Lock Execution Variables
                const p1 = this.splitLineStart;
                const p2 = this.splitLineEnd;

                // Strict guard: only execute a fully valid (green) line.
                if (!this.isSplitValid(p1, p2)) {
                    this.showToast('Only a full green line can be executed.', true);
                    this.cancelSplitLine();
                    return;
                }

                // Execution-side micro-line safety guard:
                // prevent accidental tiny cuts unless the release was an intentional flick.
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const worldLength = Math.sqrt(dx * dx + dy * dy);
                const screenLengthPx = worldLength * Math.max(0.1, this.zoom || 1);
                const minNonFlickExecuteLengthPx = 28;
                if (screenLengthPx < minNonFlickExecuteLengthPx) {
                    this.showToast('Line is too short. Drag a longer line or flick quickly to auto-cut.', true);
                    this.cancelSplitLine();
                    return;
                }

                this.splitLineStart = null;
                this.splitLineEnd = null;
                this.splitLastReleaseWasFlick = false;

                const isFunGameMode = !!(
                    window.game &&
                    window.game.currentMode &&
                    typeof window.game.currentMode.isFunModeActive === 'function' &&
                    window.game.currentMode.isFunModeActive()
                );

                // 3. Validation Phase (World Class Rules)
                // Check against ALL visible polygons. If ANY cut is invalid (e.g. stops inside), abort ALL.
                const targets = this.selectedPolygon ? [this.selectedPolygon] : this.polygons;
                let validationFailed = false;
                const promptText = "Draw a straight line across the shape.";

                if (isFunGameMode && window.game && window.game.currentMode) {
                    if (window.game.currentMode.linesUsed >= window.game.currentMode.maxLines) {
                        this.showToast('Line limit reached. Submit your solution or retry.', true);
                        validationFailed = true;
                    }
                }

                for (let poly of targets) {
                    if (!poly.visible) continue;
                    const validation = Geometry.validateCut(poly, p1, p2);
                    if (!validation.isValid) {
                        this.showToast(`Invalid Cut: ${validation.reason}`, true);
                        validationFailed = true;
                        break;
                    }
                }

                if (validationFailed) {
                    // Reset UI
                    if (isFunGameMode) {
                        this.splitStep = 1;
                        const level = (window.game && window.game.currentMode) ? (window.game.currentMode.currentLevelIndex || 0) : 0;
                        if (level === 0) {
                            this.updateSplitPrompt(promptText);
                        } else {
                            this.updateSplitPrompt("");
                        }
                        this.render(true);
                    } else {
                        this.render();
                    }
                    return;
                }

                // 4. Execution Phase (List Rebuild Strategy)
                const nextPolygons = [];
                const newlyCreatedPolys = [];
                let splitCount = 0;

                // Process every polygon in the scene
                // If selectedPolygon is set, we only attempt splitting that one, others are passed through.
                const fullList = this.polygons;

                for (let poly of fullList) {
                    let shouldAttemptSplit = false;

                    if (this.selectedPolygon) {
                        shouldAttemptSplit = (poly === this.selectedPolygon);
                    } else {
                        shouldAttemptSplit = true; // Try all in game mode / global tool
                    }

                    if (shouldAttemptSplit && poly.visible) {
                        let pieces = null;
                        try {
                            pieces = Geometry.split(poly, p1, p2);
                        } catch (e) {
                            console.error("Split calculation error:", e);
                        }

                        if (pieces && pieces.length > 1) {
                            // SUCCESS: Add NEW pieces only
                            pieces.forEach((pts, idx) => {
                                // Clean collinear vertices to ensure "Type" and vertex count are accurate
                                const cleanedPts = Geometry.cleanCollinearVertices(pts);
                                const newPoly = new Polygon(cleanedPts, poly.color);
                                newPoly.name = `${poly.name} Part ${idx + 1}`;
                                nextPolygons.push(newPoly);
                                newlyCreatedPolys.push(newPoly);
                            });
                            splitCount++;
                        } else {
                            // No split occurred (no intersection) - Keep Original
                            nextPolygons.push(poly);
                        }
                    } else {
                        // Pass through untouched
                        nextPolygons.push(poly);
                    }
                }

                // 5. Apply Results
                if (splitCount > 0) {
                    this.polygons = nextPolygons; // Atomic state update
                    this.selectedPolygon = null;
                    this.selectedVertex = null;

                    this.saveHistory();
                    this.updateProperties();
                    this.updateLayers();

                    // Notify Game Mode
                    if (window.game && window.game.currentMode && typeof window.game.currentMode.handleSlice === 'function') {
                        window.game.currentMode.handleSlice(newlyCreatedPolys);
                    }

                    // Reset UI for next action
                    if (isFunGameMode) {
                        this.splitStep = 1;
                        this.splitMode = true; // Stay in split mode
                        const level = (window.game && window.game.currentMode) ? (window.game.currentMode.currentLevelIndex || 0) : 0;
                        if (level === 0) {
                            this.updateSplitPrompt(promptText);
                        } else {
                            this.updateSplitPrompt("");
                        }
                        this.render(true);
                    } else {
                        this.exitSplitMode();
                        this.setTool('select');
                        this.render();
                    }
                } else {
                    this.showToast('No polygons were intersected by the split line.', true);
                    if (isFunGameMode) {
                        this.splitStep = 1;
                        const level = (window.game && window.game.currentMode) ? (window.game.currentMode.currentLevelIndex || 0) : 0;
                        if (level === 0) {
                            this.updateSplitPrompt(promptText);
                        } else {
                            this.updateSplitPrompt("");
                        }
                        this.render(true);
                    }
                }
            }

            // Canvas coordinate helpers
            screenToWorld(x, y) {
                // Use CSS dimensions for coordinate conversion
                const rect = this.canvas.getBoundingClientRect();
                const cssWidth = rect.width;
                const cssHeight = rect.height;
                return {
                    x: (x - cssWidth / 2 - this.pan.x) / this.zoom,
                    y: (y - cssHeight / 2 - this.pan.y) / this.zoom
                };
            }

            worldToScreen(x, y) {
                // Use CSS dimensions for coordinate conversion
                const rect = this.canvas.getBoundingClientRect();
                const cssWidth = rect.width;
                const cssHeight = rect.height;
                return {
                    x: x * this.zoom + cssWidth / 2 + this.pan.x,
                    y: y * this.zoom + cssHeight / 2 + this.pan.y
                };
            }

            snapToGrid(point) {
                if (!this.gridSnap || !point) return point;

                // Validate gridSize
                if (!this.gridSize || this.gridSize <= 0 || !isFinite(this.gridSize)) {
                    return point;
                }

                // Use epsilon for floating point precision to avoid rounding errors
                const epsilon = 1e-10;
                const gridSizeInv = 1 / this.gridSize;

                // Optimized snapping calculation
                const snappedX = Math.round((point.x + epsilon) * gridSizeInv) * this.gridSize;
                const snappedY = Math.round((point.y + epsilon) * gridSizeInv) * this.gridSize;

                // Round to avoid floating point artifacts (higher precision for better accuracy)
                return {
                    x: Math.round(snappedX * 10000) / 10000,
                    y: Math.round(snappedY * 10000) / 10000
                };
            }

            // Helper function to mark grid for redraw when state changes
            markGridForRedraw() {
                this.gridNeedsRedraw = true;
                this.lastGridState = null;
            }

            // Get the center of the current viewport in world coordinates, snapped to grid
            getViewportCenter() {
                // Get CSS dimensions (not device pixel dimensions)
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                // Convert to world coordinates
                const worldCenter = this.screenToWorld(centerX, centerY);

                // Snap to grid
                return this.snapToGrid(worldCenter);
            }

            // Mouse/Touch handlers
            handleMouseDown(e) {
                // Prevent mouse events from firing immediately after touch events
                // This avoids double handling on touch devices
                const timeSinceLastTouch = Date.now() - this.lastTouchTime;
                if (timeSinceLastTouch < 500) {
                    return; // Ignore mouse event if it happened shortly after touch
                }

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                const snappedPos = this.snapToGrid(worldPos);

                // Store initial click position for pan detection
                this.panStartPos = { x, y };

                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    // Middle button or shift+left for panning
                    this.isPanning = true;
                    this.dragStart = { x, y };
                    this.canvas.style.cursor = 'grabbing';
                    return;
                }

                // Handle Split Mode Interaction - Professional AAA Experience
                if (this.splitMode && e.button === 0) {
                    // Endpoint edit mode for a completed line
                    const endpointHit = this.findSplitEndpointAt(snappedPos);
                    if (endpointHit) {
                        this.isDragging = true;
                        this.dragStart = { x, y };
                        this.splitEditingEndpoint = endpointHit;
                        this.splitLastPointerScreen = { x, y };
                        this.canvas.style.cursor = 'crosshair';
                        return;
                    }

                    // Check for continuation (Click-Click method)
                    let isContinuation = this.splitLineStart !== null;

                    // If a completed line exists and user did not grab an endpoint,
                    // start a fresh line from this point.
                    if (isContinuation) {
                        this.splitLineStart = null;
                        this.splitLineEnd = null;
                        this.splitEditingEndpoint = null;
                        isContinuation = false;
                    }

                    this.isDragging = true;
                    this.dragStart = { x, y };

                    if (!isContinuation) {
                        // New slice starting - initialize animation state
                        this.splitLineStart = snappedPos;
                        this.sliceStartTime = Date.now();
                        this.sliceAnimationPhase = 0;
                        this.sliceGlowIntensity = 0;
                        this.sliceLastValidState = false;
                    }
                    this.splitLineEnd = snappedPos;
                    this.splitGestureStartScreen = { x, y };
                    this.splitGestureStartTime = Date.now();
                    this.splitLastReleaseWasFlick = false;

                    // Immediate visual feedback - change cursor
                    this.canvas.style.cursor = 'crosshair';

                    // Show Execute button once drawing starts
                    const btn = document.querySelector('[data-tool="split"]');
                    if (btn) btn.style.display = 'flex';

                    // Track latest pointer and render on next frame (low latency, no jank)
                    this.splitLastPointerScreen = { x, y };
                    this.scheduleSplitPreviewRender();

                    return;
                }

                // Handle Combine Mode Selection
                if (this.combineMode && e.button === 0) {
                    // Find all polygons under the click point
                    const polygonsAtPoint = [];
                    for (let i = this.polygons.length - 1; i >= 0; i--) {
                        const poly = this.polygons[i];
                        if (!poly.visible) continue;
                        if (poly.containsPoint(snappedPos)) {
                            polygonsAtPoint.push({ poly, index: i });
                        }
                    }

                    if (polygonsAtPoint.length > 0) {
                        const now = Date.now();
                        const CLICK_THRESHOLD = 500; // ms - time window for cycling
                        const DISTANCE_THRESHOLD = 20; // pixels - tolerance for same location

                        // Check if clicking same location within time window
                        let isSameLocation = false;
                        if (this.combineLastClickPos) {
                            const dx = snappedPos.x - this.combineLastClickPos.x;
                            const dy = snappedPos.y - this.combineLastClickPos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            isSameLocation = distance < DISTANCE_THRESHOLD;
                        }

                        const isWithinTimeWindow = (now - this.combineLastClickTime) < CLICK_THRESHOLD;

                        if (isSameLocation && isWithinTimeWindow && polygonsAtPoint.length > 1) {
                            // Cycle to next polygon
                            this.combineCycleIndex = (this.combineCycleIndex + 1) % polygonsAtPoint.length;
                        } else {
                            // New location or timeout - reset to first polygon
                            this.combineCycleIndex = 0;
                        }

                        // Update tracking for next click
                        this.combineLastClickPos = { x: snappedPos.x, y: snappedPos.y };
                        this.combineLastClickTime = now;

                        // Get the polygon at current cycle index
                        const targetPoly = polygonsAtPoint[this.combineCycleIndex].poly;

                        // Toggle selection for the targeted polygon
                        if (this.combineSelection.has(targetPoly)) {
                            this.combineSelection.delete(targetPoly);
                        } else {
                            this.combineSelection.add(targetPoly);
                        }

                        this.render();
                        this.updateLayers(); // Update sidebar to reflect selection
                        return;
                    }
                    return; // Don't do normal selection in combine mode
                }

                // Check if click is outside any polygon (for panning)
                const clickedOnPolygon = this.isPointOnPolygon(snappedPos);

                // If clicking outside polygons and using select tool, enable pan mode
                if (!clickedOnPolygon && this.currentTool === 'select' && e.button === 0) {
                    // Set up for potential panning - will activate on mousemove if threshold is met
                    this.dragStart = { x, y };
                    this.canvas.style.cursor = 'grab';
                    return;
                }

                switch (this.currentTool) {
                    case 'select':
                        this.handleSelect(snappedPos);
                        break;
                }
            }

            // Check if a point is on any polygon or vertex
            isPointOnPolygon(pos) {
                // Check for vertex selection first (higher priority)
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue;
                    for (let j = 0; j < poly.vertices.length; j++) {
                        const vertex = poly.vertices[j];
                        const distance = this.distance(pos, vertex);
                        const threshold = Math.max(8, 20 / this.zoom);
                        if (distance < threshold) {
                            return true; // Clicked on a vertex
                        }
                    }
                }

                // Check for polygon selection
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue;
                    if (poly.containsPoint(pos)) {
                        return true; // Clicked on a polygon
                    }
                }

                return false; // Clicked on empty space
            }

            // Find polygon and vertex at a point (returns object with polygon and vertex or null)
            findPolygonAtPoint(pos) {
                // Check for vertex selection first (higher priority)
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue;
                    for (let j = 0; j < poly.vertices.length; j++) {
                        const vertex = poly.vertices[j];
                        const distance = this.distance(pos, vertex);
                        const threshold = Math.max(8, 20 / this.zoom);
                        if (distance < threshold) {
                            return { polygon: poly, vertex: vertex }; // Clicked on a vertex
                        }
                    }
                }

                // Check for polygon selection
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue;
                    if (poly.containsPoint(pos)) {
                        return { polygon: poly, vertex: null }; // Clicked on a polygon
                    }
                }

                return null; // Clicked on empty space
            }


            handleMouseMove(e) {
                if (!(e.target === this.canvas || this.isDragging || this.isPanning || this.splitMode)) {
                    return;
                }
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                const snappedPos = this.snapToGrid(worldPos);

                // Update coordinate display (throttled for performance)
                const coordDisplay = document.getElementById('coordDisplay');
                if (coordDisplay) {
                    coordDisplay.textContent = `X: ${Math.round(snappedPos.x)}, Y: ${Math.round(snappedPos.y)}`;
                }

                // Handle Split Line Dragging
                if (this.splitMode && this.isDragging && this.splitStep === 1) {
                    if (this.splitEditingEndpoint && this.splitLineStart && this.splitLineEnd) {
                        this.splitLastPointerScreen = { x, y };
                        if (this.splitEditingEndpoint === 'start') {
                            this.splitLineStart = snappedPos;
                        } else {
                            this.splitLineEnd = snappedPos;
                        }
                        this.scheduleSplitPreviewRender();
                    } else if (this.splitLineStart) {
                        this.splitLastPointerScreen = { x, y };
                        this.updateSplitLineConstraint(snappedPos);
                        this.scheduleSplitPreviewRender();
                    }
                    return;
                }

                // Handle active panning (with early return)
                if (this.isPanning && this.dragStart) {
                    this.pan.x += x - this.dragStart.x;
                    this.pan.y += y - this.dragStart.y;
                    this.dragStart = { x, y };
                    this.canvas.style.cursor = 'grabbing';
                    // Mark grid for redraw on pan
                    this.gridNeedsRedraw = true;
                    this.render(true); // Force render during pan
                    return;
                }

                // Check if we should start panning from empty space click
                if (this.panStartPos && this.dragStart && !this.isDragging && !this.isPanning &&
                    this.currentTool === 'select' && !this.selectedPolygon) {
                    const moveDistance = Math.sqrt(
                        Math.pow(x - this.panStartPos.x, 2) +
                        Math.pow(y - this.panStartPos.y, 2)
                    );

                    // If moved beyond threshold, start panning
                    if (moveDistance > this.panThreshold) {
                        this.isPanning = true;
                        this.canvas.style.cursor = 'grabbing';
                    }
                }

                // Check if we should start dragging a selected polygon/vertex
                if (this.potentialDragStart && this.selectedPolygon && !this.isDragging && !this.isPanning) {
                    const worldMoveDistance = this.distance(snappedPos, this.potentialDragStart);

                    // Only start dragging after moving beyond threshold (in world units)
                    if (worldMoveDistance > this.dragThreshold) {
                        this.isDragging = true;
                        // Update dragStart to current position to prevent initial jump
                        this.dragStart = snappedPos;
                    }
                }


                if (this.isDragging && this.selectedVertex) {
                    // Update the vertex position directly
                    this.selectedVertex.x = snappedPos.x;
                    this.selectedVertex.y = snappedPos.y;
                    this.updateProperties();
                    this.render(true); // Force render during drag for responsiveness
                } else if (this.isDragging && this.selectedPolygon && !this.selectedVertex) {
                    const dx = snappedPos.x - this.dragStart.x;
                    const dy = snappedPos.y - this.dragStart.y;
                    this.selectedPolygon.move(dx, dy);
                    this.dragStart = snappedPos;
                    this.updateProperties();
                    this.render(true); // Force render during drag for responsiveness
                }

                // Beginner Mode: Hover Inspection
                // Only active in game mode when split tool is active (since selection is disabled)
                if (this.isGameModeActive() && this.splitMode && !this.isDragging && !this.isPanning) {
                    let hoverPoly = null;
                    // Check logic similar to selection: reverse order (top first)
                    for (let i = this.polygons.length - 1; i >= 0; i--) {
                        if (this.polygons[i].visible && this.polygons[i].containsPoint(worldPos)) {
                            hoverPoly = this.polygons[i];
                            break;
                        }
                    }

                    // Only update if changed to avoid DOM thrashing
                    if (this._lastHoverPoly !== hoverPoly) {
                        this._lastHoverPoly = hoverPoly;
                        this.updateProperties(hoverPoly);
                    }
                }
            }

            handleMouseUp(e) {
                if (!this.isDragging && !this.isPanning && e.target !== this.canvas) {
                    return;
                }
                // If we were panning, stop it
                if (this.isPanning) {
                    this.isPanning = false;
                    this.canvas.style.cursor = '';
                    this.updateCursor();
                }

                // Handle Split Mode Execution
                if (this.splitMode && this.isDragging) {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.splitLastPointerScreen = { x, y };
                    const worldPos = this.screenToWorld(x, y);
                    const snappedPos = this.snapToGrid(worldPos);

                    if (this.splitEditingEndpoint && this.splitLineStart && this.splitLineEnd) {
                        if (this.splitEditingEndpoint === 'start') {
                            this.splitLineStart = snappedPos;
                        } else {
                            this.splitLineEnd = snappedPos;
                        }
                        this.splitEditingEndpoint = null;
                        this.splitLastReleaseWasFlick = false;

                        if (!this.isSplitValid(this.splitLineStart, this.splitLineEnd)) {
                            this.cancelSplitLine();
                        } else {
                            this.scheduleSplitPreviewRender();
                        }
                    } else {
                        this.splitLineEnd = snappedPos;
                        this.splitLastReleaseWasFlick = false;

                        if (!this.isSplitValid(this.splitLineStart, this.splitLineEnd)) {
                            // Requirement: cancel immediately when released and not full green
                            this.cancelSplitLine();
                        } else {
                            // Keep completed green line so user can adjust endpoints or press Execute Split.
                            this.scheduleSplitPreviewRender();

                            // In game mode there is no split toolbar button visible,
                            // so execute the split immediately on release.
                            if (this.isGameModeActive()) {
                                this.executeSplit();
                            }
                        }
                    }
                    // Don't return, let dragging state reset below
                }

                // If we clicked but didn't pan (clicked on empty space without dragging)
                if (this.panStartPos && !this.isPanning && !this.isDragging && this.currentTool === 'select') {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const moveDistance = Math.sqrt(
                        Math.pow(x - this.panStartPos.x, 2) +
                        Math.pow(y - this.panStartPos.y, 2)
                    );

                    // If we didn't move much, treat as a click to deselect
                    if (moveDistance <= this.panThreshold) {
                        const worldPos = this.screenToWorld(x, y);
                        const snappedPos = this.snapToGrid(worldPos);

                        // Only deselect if clicking on empty space
                        if (!this.isPointOnPolygon(snappedPos)) {
                            this.selectedPolygon = null;
                            this.selectedVertex = null;
                            this.updateProperties();
                            this.updateLayers();
                            this.render();
                        }
                    }
                }

                if (this.isDragging && (this.selectedVertex || this.selectedPolygon)) {
                    this.saveHistory();
                }

                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = null;
                this.panStartPos = null;
                this.potentialDragStart = null;
            }

            handleWheel(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const worldBefore = this.screenToWorld(x, y);

                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                this.zoom = Math.max(0.1, Math.min(5, this.zoom * delta));

                const worldAfter = this.screenToWorld(x, y);

                this.pan.x += (worldAfter.x - worldBefore.x) * this.zoom;
                this.pan.y += (worldAfter.y - worldBefore.y) * this.zoom;

                // Mark grid for redraw on zoom/pan change
                this.gridNeedsRedraw = true;
                this.lastGridState = null; // Force grid state recalculation
                this.render(true); // Force render during zoom for smooth experience
            }

            handleDoubleClick(e) {
                // No double click actions
            }

            handleTouchStart(e) {
                if (e.cancelable) {
                    e.preventDefault();
                }
                e.stopPropagation();

                // Update last touch time to prevent mouse event conflicts
                this.lastTouchTime = Date.now();

                // COMPLETELY RESET all touch-related state for new touch
                // This prevents coordinate system confusion from previous touches
                this.isDragging = false;
                this.isPanning = false;
                this.touchGestureLocked = false;
                this.touchVelocity = { x: 0, y: 0 };
                this.touchLastMoveTime = Date.now();
                this.dragStart = null;
                this.panStartPos = null;
                this.touchStartPos = null;
                this.potentialDragStart = null;

                // Handle multi-touch for pan/zoom
                if (e.touches.length === 2) {
                    this.isPinching = true;
                    this.touchGestureLocked = true; // Lock to pinch gesture
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    this.pinchDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    this.pinchZoom = this.zoom;
                    // Clear any selection when pinching
                    this.selectedPolygon = null;
                    this.selectedVertex = null;
                    return;
                }

                // Single touch
                const touch = e.touches[0];
                if (!touch) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                const snappedPos = this.snapToGrid(worldPos);

                // Store initial touch position for gesture detection
                // ALWAYS use screen coordinates for these initial positions
                this.panStartPos = { x, y }; // Screen coordinates - for panning
                this.touchStartTime = Date.now();
                this.touchStartPos = { x, y }; // Screen coordinates - for movement detection
                this.touchLastMoveTime = Date.now();

                // Handle Split Mode Interaction - Professional Touch Experience
                if (this.splitMode) {
                    // Endpoint edit mode for completed line
                    const endpointHit = this.findSplitEndpointAt(snappedPos);
                    if (endpointHit) {
                        this.isDragging = true;
                        this.dragStart = { x, y };
                        this.touchGestureLocked = true;
                        this.splitEditingEndpoint = endpointHit;
                        this.splitLastPointerScreen = { x, y };
                        this.scheduleSplitPreviewRender();
                        return;
                    }

                    // Check if continuing from existing start point
                    let isContinuation = this.splitLineStart !== null;

                    // Existing completed line + non-endpoint touch => start a fresh line.
                    if (isContinuation) {
                        this.splitLineStart = null;
                        this.splitLineEnd = null;
                        this.splitEditingEndpoint = null;
                        isContinuation = false;
                    }

                    this.isDragging = true;
                    this.dragStart = { x, y }; // Screen coords
                    this.touchGestureLocked = true; // Lock to slice gesture immediately

                    if (!isContinuation) {
                        // New slice starting - initialize animation state
                        this.splitLineStart = snappedPos;
                        this.sliceStartTime = Date.now();
                        this.sliceAnimationPhase = 0;
                        this.sliceGlowIntensity = 0;
                        this.sliceLastValidState = false;
                    }
                    this.splitLineEnd = snappedPos;
                    this.splitGestureStartScreen = { x, y };
                    this.splitGestureStartTime = Date.now();
                    this.splitLastReleaseWasFlick = false;

                    const btn = document.querySelector('[data-tool="split"]');
                    if (btn) btn.style.display = 'flex';

                    this.splitLastPointerScreen = { x, y };
                    this.scheduleSplitPreviewRender();

                    return;
                }

                // Handle Combine Mode Selection
                if (this.combineMode) {
                    for (let i = this.polygons.length - 1; i >= 0; i--) {
                        const poly = this.polygons[i];
                        if (!poly.visible) continue;
                        if (poly.containsPoint(snappedPos)) {
                            if (this.combineSelection.has(poly)) {
                                this.combineSelection.delete(poly);
                            } else {
                                this.combineSelection.add(poly);
                            }
                            this.render();
                            this.updateLayers();
                            return;
                        }
                    }
                    return;
                }

                // For select tool, immediately check if we hit a polygon
                if (this.currentTool === 'select') {
                    // Check if touch is directly on a polygon or vertex
                    const polygonHit = this.findPolygonAtPoint(snappedPos);

                    if (polygonHit) {
                        // Immediately select the polygon for instant feedback
                        this.selectedPolygon = polygonHit.polygon;
                        if (polygonHit.vertex) {
                            this.selectedVertex = polygonHit.vertex;
                            // Lock to drag gesture when touching vertex
                            this.touchGestureLocked = true;
                            // Immediately enable dragging for vertices - no threshold needed
                            this.isDragging = true;
                            // Use world coordinates for vertex dragging
                            this.dragStart = snappedPos; // World coordinates for vertex drag
                            this.potentialDragStart = snappedPos;
                            // panStartPos already set to screen coordinates above
                        } else {
                            this.selectedVertex = null;
                            // Prepare for potential drag, but wait for movement threshold
                            // Use world coordinates for polygon dragging
                            this.dragStart = snappedPos; // World coordinates for polygon drag
                            this.potentialDragStart = snappedPos;
                            // panStartPos already set to screen coordinates above
                            // Don't lock gesture yet - allow panning if moved far enough
                        }
                        this.updateProperties();
                        this.updateLayers();
                        this.render();
                        return;
                    } else {
                        // Touching empty space - prepare for panning, but allow quick tap to deselect
                        // Don't set dragStart here - it will be set when panning actually starts
                        // panStartPos already set to screen coordinates above
                        this.canvas.style.cursor = 'grab';
                        // Don't lock gesture - will determine based on movement
                        // Don't deselect immediately - wait for touch end to see if it's a tap
                    }
                }
            }

            handleTouchMove(e) {
                if (e.cancelable) {
                    e.preventDefault();
                }
                e.stopPropagation();

                // Handle pinch-to-zoom
                if (e.touches.length === 2 && this.isPinching) {
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const distance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );

                    if (this.pinchDistance > 0) {
                        const scale = distance / this.pinchDistance;
                        this.zoom = Math.max(0.1, Math.min(5, this.pinchZoom * scale));
                        // Mark grid for redraw on zoom
                        this.gridNeedsRedraw = true;
                        this.lastGridState = null;
                        this.render(true); // Force render during pinch zoom for smooth experience
                    }
                    return;
                }

                // Single touch move
                const touch = e.touches[0];
                if (!touch) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                const snappedPos = this.snapToGrid(worldPos);

                // Calculate velocity for gesture detection
                // ALWAYS use screen coordinates (touchStartPos) for velocity calculation
                // Never use dragStart as it might be in world coordinates
                const now = Date.now();
                const timeDelta = Math.max(1, now - this.touchLastMoveTime);
                if (this.touchStartPos && timeDelta > 0) {
                    // Use touchStartPos which is always in screen coordinates
                    this.touchVelocity.x = (x - this.touchStartPos.x) / timeDelta;
                    this.touchVelocity.y = (y - this.touchStartPos.y) / timeDelta;
                }
                this.touchLastMoveTime = now;

                // Update coordinate display (throttled)
                const coordDisplay = document.getElementById('coordDisplay');
                if (coordDisplay) {
                    coordDisplay.textContent = `X: ${Math.round(snappedPos.x)}, Y: ${Math.round(snappedPos.y)}`;
                }

                // Calculate movement distance from touch start
                let moveDistance = 0;
                if (this.touchStartPos) {
                    moveDistance = Math.sqrt(
                        Math.pow(x - this.touchStartPos.x, 2) +
                        Math.pow(y - this.touchStartPos.y, 2)
                    );
                }

                // Handle Split Line Dragging
                if (this.splitMode && this.isDragging) {
                    if (this.splitEditingEndpoint && this.splitLineStart && this.splitLineEnd) {
                        this.splitLastPointerScreen = { x, y };
                        if (this.splitEditingEndpoint === 'start') {
                            this.splitLineStart = snappedPos;
                        } else {
                            this.splitLineEnd = snappedPos;
                        }
                        this.scheduleSplitPreviewRender();
                    } else if (this.splitLineStart) {
                        this.splitLastPointerScreen = { x, y };
                        this.updateSplitLineConstraint(snappedPos);
                        this.scheduleSplitPreviewRender();
                    }
                    return;
                }

                // Determine gesture type if not locked yet
                if (!this.touchGestureLocked && this.touchStartPos && moveDistance > 5) {
                    // Check if we should lock to pan or drag
                    if (this.selectedPolygon && !this.selectedVertex) {
                        // If touching a polygon (not vertex), allow both drag and pan
                        // Lock to drag if movement is small and consistent
                        if (moveDistance > this.touchDragThreshold && moveDistance < this.touchPanThreshold) {
                            this.touchGestureLocked = true;
                            this.isDragging = true;
                            // Ensure panStartPos is set for potential pan fallback
                            if (!this.panStartPos) {
                                this.panStartPos = { x, y };
                            }
                        } else if (moveDistance > this.touchPanThreshold) {
                            // Large movement - prefer panning unless clearly dragging polygon
                            const velocity = Math.sqrt(this.touchVelocity.x ** 2 + this.touchVelocity.y ** 2);
                            if (velocity < 0.5) { // Slow movement - likely dragging polygon
                                this.touchGestureLocked = true;
                                this.isDragging = true;
                                // Ensure panStartPos is set for potential pan fallback
                                if (!this.panStartPos) {
                                    this.panStartPos = { x, y };
                                }
                            } else {
                                // Fast movement - likely panning
                                this.touchGestureLocked = true;
                                this.isPanning = true;
                                this.isDragging = false;
                                // Clear polygon selection when switching to pan
                                this.selectedPolygon = null;
                                this.selectedVertex = null;
                                // Reset dragStart since we're switching to pan (different coordinate system)
                                this.dragStart = null;
                                // CRITICAL: Reset panStartPos to initial touch position to prevent jump
                                // This ensures smooth panning from the start point, not from current position
                                if (this.touchStartPos) {
                                    this.panStartPos = { x: this.touchStartPos.x, y: this.touchStartPos.y };
                                } else {
                                    // Fallback: use current position if touchStartPos somehow missing
                                    this.panStartPos = { x, y };
                                }
                                this.canvas.style.cursor = 'grabbing';
                            }
                        }
                    } else if (!this.selectedPolygon) {
                        // Empty space - lock to pan if moved enough
                        if (moveDistance > this.touchPanThreshold) {
                            this.touchGestureLocked = true;
                            this.isPanning = true;
                            // Clear any polygon-related drag state
                            this.dragStart = null;
                            // CRITICAL: Reset panStartPos to initial touch position to prevent jump
                            // This ensures smooth panning from the start point
                            if (this.touchStartPos) {
                                this.panStartPos = { x: this.touchStartPos.x, y: this.touchStartPos.y };
                            } else {
                                // Fallback: use current position if touchStartPos somehow missing
                                this.panStartPos = { x, y };
                            }
                            this.canvas.style.cursor = 'grabbing';
                        }
                    }
                }

                // Continue panning if active
                if (this.isPanning && this.panStartPos) {
                    // Use panStartPos which is always in screen coordinates
                    const dx = x - this.panStartPos.x;
                    const dy = y - this.panStartPos.y;

                    // Safety check: prevent huge jumps that indicate coordinate system error
                    // If delta is too large (>500px), something is wrong - reset panStartPos
                    const deltaMagnitude = Math.sqrt(dx * dx + dy * dy);
                    if (deltaMagnitude > 500) {
                        // Reset to current position to prevent jump
                        this.panStartPos = { x, y };
                        this.render(true);
                        return;
                    }

                    // Prevent extreme pan values that could cause viewport jumping
                    const maxPan = 10000; // Reasonable maximum pan value
                    const newPanX = this.pan.x + dx;
                    const newPanY = this.pan.y + dy;

                    // Clamp pan values to prevent viewport jumping
                    if (Math.abs(newPanX) < maxPan && Math.abs(newPanY) < maxPan) {
                        this.pan.x = newPanX;
                        this.pan.y = newPanY;
                    }

                    // Update panStartPos for next frame (screen coordinates)
                    this.panStartPos = { x, y };
                    // Mark grid for redraw on pan
                    this.gridNeedsRedraw = true;
                    this.render(true); // Force render during pan
                    return;
                }

                // Handle dragging selected polygon or vertex
                // For vertices, start dragging immediately when touched (no threshold)
                if (this.selectedVertex && this.touchGestureLocked) {
                    // Vertex dragging - update position directly
                    this.selectedVertex.x = snappedPos.x;
                    this.selectedVertex.y = snappedPos.y;
                    this.updateProperties();
                    this.render(true); // Force render during drag
                } else if (this.isDragging) {
                    if (this.selectedVertex) {
                        // Drag vertex (fallback - should be handled above)
                        this.selectedVertex.x = snappedPos.x;
                        this.selectedVertex.y = snappedPos.y;
                        this.updateProperties();
                        this.render(true); // Force render during drag
                    } else if (this.selectedPolygon && this.dragStart) {
                        // Drag polygon
                        const dx = snappedPos.x - this.dragStart.x;
                        const dy = snappedPos.y - this.dragStart.y;
                        this.selectedPolygon.move(dx, dy);
                        this.dragStart = snappedPos;
                        this.render(true); // Force render during drag
                    }
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                e.stopPropagation();

                // Handle Split Mode Execution (Touch)
                if (this.splitMode && this.isDragging) {
                    // Check if we have a touch position (from change)
                    if (e.changedTouches[0]) {
                        const touch = e.changedTouches[0];
                        const rect = this.canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        this.splitLastPointerScreen = { x, y };
                        const worldPos = this.screenToWorld(x, y);
                        const snappedPos = this.snapToGrid(worldPos);

                        if (this.splitEditingEndpoint && this.splitLineStart && this.splitLineEnd) {
                            if (this.splitEditingEndpoint === 'start') {
                                this.splitLineStart = snappedPos;
                            } else {
                                this.splitLineEnd = snappedPos;
                            }
                            this.splitEditingEndpoint = null;
                            this.splitLastReleaseWasFlick = false;

                            if (!this.isSplitValid(this.splitLineStart, this.splitLineEnd)) {
                                this.cancelSplitLine();
                            } else {
                                this.scheduleSplitPreviewRender();
                            }
                        } else {
                            this.splitLineEnd = snappedPos;
                            this.splitLastReleaseWasFlick = false;

                            if (!this.isSplitValid(this.splitLineStart, this.splitLineEnd)) {
                                // Requirement: cancel immediately when released and not full green
                                this.cancelSplitLine();
                            } else {
                                // Keep completed green line so user can adjust endpoints or press Execute Split.
                                this.scheduleSplitPreviewRender();

                                // In game mode there is no split toolbar button visible,
                                // so execute the split immediately on release.
                                if (this.isGameModeActive()) {
                                    this.executeSplit();
                                }
                            }
                        }
                    }
                }

                // Update last touch time
                this.lastTouchTime = Date.now();
                this.isPinching = false;

                // Handle touch end similar to mouse up
                if (this.isPanning) {
                    this.isPanning = false;
                    this.canvas.style.cursor = '';
                    this.updateCursor();
                }

                // Save history if we dragged something
                if (this.isDragging && (this.selectedVertex || this.selectedPolygon)) {
                    this.saveHistory();
                }

                // Calculate final movement distance
                let finalMoveDistance = 0;
                if (this.touchStartPos && e.changedTouches[0]) {
                    const touch = e.changedTouches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    finalMoveDistance = Math.sqrt(
                        Math.pow(x - this.touchStartPos.x, 2) +
                        Math.pow(y - this.touchStartPos.y, 2)
                    );
                }

                // If we tapped (didn't pan or drag), handle tap for deselection
                if (this.touchStartPos && !this.isPanning && !this.isDragging &&
                    this.currentTool === 'select' && finalMoveDistance <= this.touchTapThreshold) {
                    const touch = e.changedTouches[0];
                    if (touch) {
                        const rect = this.canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        const worldPos = this.screenToWorld(x, y);
                        const snappedPos = this.snapToGrid(worldPos);

                        // Check if tapping on empty space - if so, deselect and show grid clearly
                        const polygonHit = this.findPolygonAtPoint(snappedPos);
                        if (!polygonHit) {
                            // Tapped empty space - deselect everything and show grid
                            // IMPORTANT: Clear all drag/pan state before deselecting to prevent coordinate issues
                            this.isDragging = false;
                            this.isPanning = false;
                            this.dragStart = null;
                            this.panStartPos = null;
                            this.selectedPolygon = null;
                            this.selectedVertex = null;
                            this.updateProperties();
                            this.updateLayers();
                            this.render();
                            // Grid will automatically be visible since nothing is selected
                        }
                    }
                }

                // COMPLETELY RESET all touch state to prevent any residual state
                // This is critical to prevent coordinate system confusion on next touch
                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = null;
                this.panStartPos = null;
                this.touchStartTime = null;
                this.touchStartPos = null;
                this.touchGestureLocked = false;
                this.touchVelocity = { x: 0, y: 0 };
                this.touchLastMoveTime = 0;
                this.potentialDragStart = null;
            }

            handleKeyDown(e) {
                // Handle F11 for fullscreen toggle
                if (e.key === 'F11') {
                    e.preventDefault(); // Prevent browser default and use our handler for consistency
                    this.toggleFullscreen();
                    return;
                }
                // Quick shape creation shortcuts when menu is open
                if (this.shapeMenuOpen) {
                    const shortcutMap = {
                        't': 'triangle',
                        's': 'square',
                        'r': 'rectangle',
                        'p': 'pentagon',
                        'h': 'hexagon',
                        '7': 'heptagon',
                        'o': 'octagon'
                    };

                    const key = e.key.toLowerCase();
                    if (shortcutMap[key]) {
                        e.preventDefault();
                        const option = document.querySelector(`[data-shape="${shortcutMap[key]}"]`);
                        if (option) this.selectShape(option);
                        return;
                    }
                }

                switch (e.key.toLowerCase()) {
                    case 's':
                        if (!e.ctrlKey && !this.shapeMenuOpen) this.setTool('select');
                        break;
                    case 'z':
                        if (e.ctrlKey) this.undo();
                        break;
                    case 'y':
                        if (e.ctrlKey) this.redo();
                        break;
                    case 'delete':
                        this.deleteSelected();
                        break;
                    case 'escape':
                        this.cancelCurrentAction();
                        break;
                    case ' ':
                        e.preventDefault();
                        this.isPanning = true;
                        this.canvas.style.cursor = 'grab';
                        break;
                }
            }

            handleKeyUp(e) {
                if (e.key === ' ') {
                    this.isPanning = false;
                    this.updateCursor();
                }
            }

            handleSelect(pos) {
                this.selectedVertex = null;
                this.selectedPolygon = null;

                // Check for vertex selection first (higher priority)
                // Iterate backwards to select from top-most polygons first
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue; // Skip invisible polygons
                    for (let j = 0; j < poly.vertices.length; j++) {
                        const vertex = poly.vertices[j];
                        const distance = this.distance(pos, vertex);

                        // Make sure we're using a reasonable threshold that works at all zoom levels
                        // Use a dynamic threshold that's large enough to be easily clickable
                        const threshold = Math.max(8, 20 / this.zoom);

                        if (distance < threshold) {
                            this.selectedPolygon = poly;
                            this.selectedVertex = vertex;
                            // Don't set isDragging=true yet - wait for actual mouse movement
                            this.potentialDragStart = pos;
                            this.dragStart = pos;
                            this.updateProperties();
                            this.updateLayers();
                            this.render();
                            return;
                        }
                    }
                }

                // Check for polygon selection
                // Iterate backwards to select top-most polygon first
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue; // Skip invisible polygons
                    if (poly.containsPoint(pos)) {
                        this.selectedPolygon = poly;
                        // Don't set isDragging=true yet - wait for actual mouse movement
                        this.potentialDragStart = pos;
                        this.dragStart = pos;
                        this.updateProperties();
                        this.updateLayers();
                        this.render();
                        return;
                    }
                }

                this.updateProperties();
                this.updateLayers();
                this.render();
            }

            // Geometry calculations
            distance(p1, p2) {
                return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
            }

            // UI Updates
            updateCursor() {
                // Don't override grab/grabbing cursors during panning
                if (this.isPanning) {
                    this.canvas.style.cursor = 'grabbing';
                    return;
                }

                // Professional cursor for split mode
                if (this.splitMode) {
                    if (this.isDragging && this.splitLineStart) {
                        // Actively drawing a slice
                        this.canvas.style.cursor = 'crosshair';
                    } else {
                        // Ready to slice
                        this.canvas.style.cursor = 'crosshair';
                    }
                    return;
                }

                const cursors = {
                    'select': 'default',
                };
                this.canvas.style.cursor = cursors[this.currentTool] || 'default';
            }

            updateGridSnapControlLabel() {
                const toggle = document.getElementById('gridSnapToggle');
                const label = document.getElementById('gridSnapLabel');
                const isOn = !!this.gridSnap;
                if (toggle && toggle.checked !== isOn) {
                    toggle.checked = isOn;
                }
                if (label) {
                    label.textContent = `Grid Snap: ${isOn ? 'On' : 'Off'}`;
                }
            }

            updateProperties(targetPoly = null) {
                const panel = document.getElementById('propertiesPanelContent');
                let polyToView = targetPoly || this.selectedPolygon;

                // Game Mode Persistence:
                // If we are in Game Mode and no polygon is explicitly provided or selected,
                // try to stick to the last viewed one to avoid flickering/clearing during interactions.
                if (this.isGameModeActive() && !polyToView) {
                    if (this.lastViewedPolygon && this.polygons.includes(this.lastViewedPolygon)) {
                        polyToView = this.lastViewedPolygon;
                    } else if (this.polygons.length > 0) {
                        // Fallback to the first polygon (usually the target shape in early levels)
                        polyToView = this.polygons[0];
                    }
                }

                if (!polyToView) {
                    panel.innerHTML = '<div class="property-row" style="justify-content: center; padding: 12px;"><span class="property-label" style="color: #94a3b8; font-style: italic;">Select or hover over a polygon to view properties</span></div>';
                    return;
                }

                // Cache it for next time
                this.lastViewedPolygon = polyToView;

                const areaPx = Math.abs(polyToView.getArea());
                const perimeterPx = polyToView.getPerimeter();

                const area = areaPx / (this.gridSize * this.gridSize);
                const perimeter = perimeterPx / this.gridSize;
                const vertices = polyToView.vertices.length;

                // Determine Polygon Type based on vertices
                let polyType = 'Polygon';
                const vCount = polyToView.vertices.length;
                if (vCount === 3) polyType = 'Triangle';
                else if (vCount === 4) polyType = 'Quadrilateral';
                else if (vCount === 5) polyType = 'Pentagon';
                else if (vCount === 6) polyType = 'Hexagon';
                else if (vCount === 7) polyType = 'Heptagon';
                else if (vCount === 8) polyType = 'Octagon';
                else if (vCount === 9) polyType = 'Nonagon';
                else if (vCount === 10) polyType = 'Decagon';
                else if (vCount === 12) polyType = 'Dodecagon';
                else polyType = `${vCount}-gon`;

                let html = `
            <div class="property-row">
                <span class="property-label">Type:</span>
                <span class="property-value">${polyType}</span>
            </div>
            <div class="property-row">
                <span class="property-label">Vertices:</span>
                <span class="property-value">${vertices}</span>
            </div>
            <div class="property-row">
                <span class="property-label">Perimeter:</span>
                <span class="property-value">${perimeter.toFixed(2)} units</span>
            </div>
            <div class="property-row">
                <span class="property-label">Area:</span>
                <span class="property-value">${area.toFixed(2)} sq units</span>
            </div>
        `;

                // Add triangle classifier if it's a triangle
                if (vertices === 3) {
                    const classification = this.classifyTriangle(polyToView);
                    html += `
                <div class="triangle-classifier">
                    <div class="triangle-classifier-title">Triangle Type:</div>
                    <span class="classifier-badge">${classification.sides}</span>
                    <span class="classifier-badge">${classification.angles}</span>
                </div>
            `;
                }

                panel.innerHTML = html;
            }

            updateLayers() {
                const list = document.getElementById('layersList');
                document.getElementById('layerCount').textContent = this.polygons.length;

                list.innerHTML = '';
                this.polygons.forEach((poly, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    if ((this.combineMode && this.combineSelection.has(poly)) ||
                        (!this.combineMode && poly === this.selectedPolygon)) {
                        item.classList.add('selected');
                    }

                    item.innerHTML = `
                <div class="layer-color" style="background: ${poly.color}"></div>
                <div class="layer-name">${poly.name}</div>
                <div class="layer-actions">
                    <button class="layer-action-btn" onclick="app.togglePolygonVisibility(${index})" title="${poly.visible ? 'Hide' : 'Show'}">
                        ${poly.visible
                            ? 'ðŸ‘ï¸'
                            : '<div style="position:relative; display:inline-block;">ðŸ‘ï¸<div style="position:absolute; top:50%; left:-2px; right:-2px; height:2px; background:red; transform:rotate(-45deg); pointer-events:none;"></div></div>'}
                    </button>
                    <button class="layer-action-btn" onclick="app.deletePolygon(${index})" title="Delete">ðŸ—‘ï¸</button>
                </div>
            `;

                    item.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('layer-action-btn')) {
                            if (this.combineMode) {
                                if (this.combineSelection.has(poly)) {
                                    this.combineSelection.delete(poly);
                                } else {
                                    this.combineSelection.add(poly);
                                }
                                this.render();
                                this.updateLayers();
                            } else {
                                this.selectedPolygon = poly;
                                this.updateProperties();
                                this.updateLayers();
                                this.render();
                            }
                        }
                    });

                    list.appendChild(item);
                });
            }

            classifyTriangle(polygon) {
                const v = polygon.vertices;
                if (v.length !== 3) return null;

                // Calculate side lengths
                const sides = [
                    this.distance(v[0], v[1]),
                    this.distance(v[1], v[2]),
                    this.distance(v[2], v[0])
                ];

                // Classify by sides
                let sideType;
                const tolerance = 1;
                if (Math.abs(sides[0] - sides[1]) < tolerance &&
                    Math.abs(sides[1] - sides[2]) < tolerance) {
                    sideType = 'Equilateral';
                } else if (Math.abs(sides[0] - sides[1]) < tolerance ||
                    Math.abs(sides[1] - sides[2]) < tolerance ||
                    Math.abs(sides[0] - sides[2]) < tolerance) {
                    sideType = 'Isosceles';
                } else {
                    sideType = 'Scalene';
                }

                // Calculate angles
                const angles = [];
                for (let i = 0; i < 3; i++) {
                    const v1 = v[i];
                    const v2 = v[(i + 1) % 3];
                    const v3 = v[(i + 2) % 3];

                    const a = this.distance(v2, v3);
                    const b = this.distance(v1, v3);
                    const c = this.distance(v1, v2);

                    const angle = Math.acos((b * b + c * c - a * a) / (2 * b * c)) * 180 / Math.PI;
                    angles.push(angle);
                }

                // Classify by angles
                let angleType;
                if (angles.some(a => Math.abs(a - 90) < 1)) {
                    angleType = 'Right';
                } else if (angles.some(a => a > 90)) {
                    angleType = 'Obtuse';
                } else {
                    angleType = 'Acute';
                }

                return { sides: sideType, angles: angleType };
            }

            isSplitValid(p1, p2) {
                const cacheKey = [
                    Math.round(p1.x * 10), Math.round(p1.y * 10),
                    Math.round(p2.x * 10), Math.round(p2.y * 10),
                    this.polygons.length,
                    this.selectedPolygon ? this.selectedPolygon.name : '*',
                    this.historyIndex
                ].join('|');
                if (this.splitValidityCache.key === cacheKey) {
                    return this.splitValidityCache.value;
                }

                // Minimum length check (5 pixels) to prevent instant green on click
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                if ((dx * dx + dy * dy) < 16) {
                    this.splitValidityCache = { key: cacheKey, value: false, ts: performance.now() };
                    return false;
                }

                // Determine targets
                let targets = this.polygons;
                if (this.selectedPolygon) {
                    targets = [this.selectedPolygon];
                }

                // Explicit Segment-Segment Intersection Algorithm
                // Returns true if segments (a,b) and (c,d) intersect strictly
                const getSegmentIntersection = (a, b, c, d) => {
                    const s1_x = b.x - a.x;
                    const s1_y = b.y - a.y;
                    const s2_x = d.x - c.x;
                    const s2_y = d.y - c.y;

                    const s_numer = -s1_y * (a.x - c.x) + s1_x * (a.y - c.y);
                    const t_numer = s2_x * (a.y - c.y) - s2_y * (a.x - c.x);
                    const denom = -s2_x * s1_y + s1_x * s2_y;

                    if (Math.abs(denom) < 1e-9) return false; // Parallel

                    const s = s_numer / denom;
                    const t = t_numer / denom;

                    // Check for strict intersection (0 < s < 1 and 0 < t < 1)
                    // We use a small epsilon to avoid edge cases causing false negatives on exact hits
                    // but usually for "crossing" we want strictly inside.
                    if (!(s >= 0 && s <= 1 && t >= 0 && t <= 1)) {
                        return null;
                    }

                    return {
                        x: a.x + (t * s1_x),
                        y: a.y + (t * s1_y)
                    };
                };

                let isValid = false;
                for (let poly of targets) {
                    if (!poly.visible) continue;

                    const hits = [];
                    const verts = poly.vertices;
                    for (let i = 0; i < verts.length; i++) {
                        const v1 = verts[i];
                        const v2 = verts[(i + 1) % verts.length];

                        // Check intersection between split line (p1, p2) and edge (v1, v2)
                        const hit = getSegmentIntersection(p1, p2, v1, v2);
                        if (hit) {
                            // Deduplicate vertex hits (same point reported by 2 adjacent edges)
                            const duplicate = hits.some(h => Math.abs(h.x - hit.x) < 0.01 && Math.abs(h.y - hit.y) < 0.01);
                            if (!duplicate) hits.push(hit);
                        }
                    }

                    // Must cross at least 2 edges to split
                    if (hits.length >= 2) {
                        isValid = true;
                        break;
                    }
                }

                this.splitValidityCache = { key: cacheKey, value: isValid, ts: performance.now() };
                return isValid;
            }

            // Rendering
            render(force = false) {
                // Throttle render calls for better performance
                const now = performance.now();

                // Cancel any pending render if a new one is requested
                if (this.renderAnimationFrameId !== null) {
                    cancelAnimationFrame(this.renderAnimationFrameId);
                    this.renderAnimationFrameId = null;
                }

                if (!force && this.renderScheduled) {
                    return;
                }

                if (!force && (now - this.lastRenderTime) < this.renderThrottleMs) {
                    if (!this.renderScheduled) {
                        this.renderScheduled = true;
                        this.renderAnimationFrameId = requestAnimationFrame(() => {
                            this.renderScheduled = false;
                            this.renderAnimationFrameId = null;
                            this.render(true);
                        });
                    }
                    return;
                }

                this.lastRenderTime = now;
                this.renderScheduled = false;

                const removedSample = this.pruneSamplePolygonForGame();
                if (removedSample) {
                    this.updateLayers();
                    this.updateProperties();
                }
                this.updateGridSnapControlLabel();

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Save context state
                this.ctx.save();

                // Get CSS dimensions for coordinate calculations (context is already scaled by DPR)
                const rect = this.canvas.getBoundingClientRect();
                const cssWidth = rect.width;
                const cssHeight = rect.height;

                // Apply transformations
                this.ctx.translate(cssWidth / 2 + this.pan.x, cssHeight / 2 + this.pan.y);
                this.ctx.scale(this.zoom, this.zoom);

                // Draw grid FIRST before any other operations
                // This ensures grid is always drawn and not affected by other drawing operations
                this.drawGrid();

                // Draw visualizers
                if (this.visualizers.size > 0 && this.selectedPolygon) {
                    this.drawVisualizers();
                }

                // Draw polygons
                for (let poly of this.polygons) {
                    // Ensure polygon is visible (default to true if property doesn't exist)
                    if (poly.visible === false) continue;
                    let isSelected = poly === this.selectedPolygon;

                    // Highlight polygons selected for combination OR the primary selection in Split mode
                    if ((this.combineMode && this.combineSelection.has(poly)) ||
                        (this.splitMode && poly === this.selectedPolygon)) {
                        this.ctx.save();
                        this.ctx.shadowColor = '#ed8936'; // Orange/Gold glow
                        this.ctx.shadowBlur = 15;
                        this.drawPolygon(poly, true);
                        this.ctx.restore();
                    } else {
                        this.drawPolygon(poly, isSelected);
                    }
                }

                // Draw Split Line - Professional AAA Quality Rendering
                if (this.splitMode && this.splitLineStart && this.splitLineEnd) {
                    this.drawProfessionalSliceLine();
                }

                this.ctx.restore();
            }

            drawGrid() {
                // Safety check: ensure gridSize is valid
                if (!this.gridSize || this.gridSize <= 0 || !isFinite(this.gridSize)) {
                    return;
                }

                // Save context state BEFORE any grid operations
                // This preserves the current transformation matrix (translate/scale)
                this.ctx.save();

                // Get CSS dimensions for coordinate calculations
                const rect = this.canvas.getBoundingClientRect();
                const cssWidth = rect.width;
                const cssHeight = rect.height;

                // Safety check: ensure dimensions are valid
                if (!cssWidth || !cssHeight || !isFinite(cssWidth) || !isFinite(cssHeight)) {
                    this.ctx.restore(); // Restore context before returning
                    return;
                }

                // Calculate view bounds with improved precision
                const halfWidth = cssWidth / 2;
                const halfHeight = cssHeight / 2;
                const zoomInv = 1 / this.zoom;
                const panXZoom = this.pan.x * zoomInv;
                const panYZoom = this.pan.y * zoomInv;

                const viewBounds = {
                    left: -halfWidth * zoomInv - panXZoom,
                    right: halfWidth * zoomInv - panXZoom,
                    top: -halfHeight * zoomInv - panYZoom,
                    bottom: halfHeight * zoomInv - panYZoom
                };

                // Check if grid state changed (for caching optimization)
                // Note: We don't track selectedPolygon anymore since grid color is consistent
                const currentGridState = {
                    gridSize: this.gridSize,
                    zoom: this.zoom,
                    panX: Math.round(this.pan.x * 100) / 100,
                    panY: Math.round(this.pan.y * 100) / 100,
                    cssWidth: Math.round(cssWidth),
                    cssHeight: Math.round(cssHeight)
                };

                // ALWAYS draw the grid - disable aggressive caching that was causing issues
                // The grid must be drawn every frame to ensure it's always visible
                // Performance is acceptable since grid drawing is already optimized

                // Update state tracking (for potential future optimizations)
                // But never skip drawing based on this
                this.lastGridState = currentGridState;
                this.gridViewBounds = viewBounds;
                this.gridNeedsRedraw = false;

                // Calculate effective grid size in screen pixels for adaptive rendering
                const gridSizeScreen = this.gridSize * this.zoom;

                // Adaptive grid density: optimize rendering based on zoom level
                // Skip if grid lines are less than 2 pixels apart (too dense)
                if (gridSizeScreen < 2) {
                    // Draw major grid lines only with adaptive spacing
                    let majorGridMultiplier;
                    if (gridSizeScreen < 0.3) {
                        majorGridMultiplier = 50; // Very zoomed out - show every 50th line
                    } else if (gridSizeScreen < 0.5) {
                        majorGridMultiplier = 20; // Zoomed out - show every 20th line
                    } else if (gridSizeScreen < 1) {
                        majorGridMultiplier = 10; // Moderately zoomed out - show every 10th line
                    } else {
                        majorGridMultiplier = 5; // Slightly zoomed out - show every 5th line
                    }
                    this.drawGridLines(viewBounds, this.gridSize * majorGridMultiplier, true);
                    this.ctx.restore(); // Restore context before returning
                    return;
                }

                // Skip if grid lines are more than 200 pixels apart (too sparse)
                if (gridSizeScreen > 200) {
                    // Draw sub-grid lines for better visibility when zoomed in
                    const subGridSize = this.gridSize / 5;
                    // Only draw sub-grid if it's visible (not too small)
                    if (subGridSize * this.zoom > 1) {
                        this.drawGridLines(viewBounds, subGridSize, false);
                    }
                    this.drawGridLines(viewBounds, this.gridSize, true);
                    this.ctx.restore(); // Restore context before returning
                    return;
                }

                // Normal grid rendering - optimized batch drawing
                // For optimal visibility, always draw the main grid
                this.drawGridLines(viewBounds, this.gridSize, false);

                // Restore context state after drawing grid
                this.ctx.restore();
            }

            drawGridLines(viewBounds, gridSize, isMajor = false) {
                // Safety check: ensure gridSize is valid
                if (!gridSize || gridSize <= 0 || !isFinite(gridSize)) {
                    return;
                }

                // Consistent grid colors - ALWAYS use these exact colors
                // Never change based on selection or any other state
                const gridColor = isMajor ? '#c0c0c0' : '#d8d8d8';

                // Optimize line width calculation - consistent line widths
                const zoomInv = 1 / this.zoom;
                const baseLineWidth = isMajor ? 1.2 : 0.9;
                const lineWidth = baseLineWidth * zoomInv;

                // Clamp line width to reasonable bounds for performance and visibility
                const clampedLineWidth = Math.max(0.5, Math.min(2.0, lineWidth));

                // CRITICAL: Explicitly set all stroke properties to ensure consistency
                // Reset any previous state that might affect grid rendering
                this.ctx.strokeStyle = gridColor;
                this.ctx.lineWidth = clampedLineWidth;
                this.ctx.lineCap = 'butt';
                this.ctx.lineJoin = 'miter';
                this.ctx.setLineDash([]); // Ensure no dash pattern
                this.ctx.globalAlpha = 1.0; // Ensure full opacity
                this.ctx.globalCompositeOperation = 'source-over'; // Ensure normal blending

                // Calculate grid line bounds with improved precision and safety checks
                // Use epsilon to handle edge cases near zero
                const epsilon = 1e-10;
                const startX = Math.floor((viewBounds.left - epsilon) / gridSize) * gridSize;
                const endX = Math.ceil((viewBounds.right + epsilon) / gridSize) * gridSize;
                const startY = Math.floor((viewBounds.top - epsilon) / gridSize) * gridSize;
                const endY = Math.ceil((viewBounds.bottom + epsilon) / gridSize) * gridSize;

                // Safety check: ensure bounds are valid
                if (!isFinite(startX) || !isFinite(endX) || !isFinite(startY) || !isFinite(endY)) {
                    return;
                }

                // Limit number of lines to prevent performance issues (increased limit for better quality)
                const maxLines = 800; // Increased from 500 for better grid visibility
                const numVerticalLines = Math.floor((endX - startX) / gridSize) + 1;
                const numHorizontalLines = Math.floor((endY - startY) / gridSize) + 1;

                if (numVerticalLines > maxLines || numHorizontalLines > maxLines ||
                    numVerticalLines < 0 || numHorizontalLines < 0) {
                    // Too many lines or invalid count - skip drawing to prevent lag
                    // Draw only major lines in this case
                    if (isMajor) {
                        const majorSpacing = Math.max(gridSize * 5, (endX - startX) / 50);
                        this.drawGridLines(viewBounds, majorSpacing, true);
                    }
                    return;
                }

                // Optimize: Batch draw vertical lines for better performance
                this.ctx.beginPath();
                // Pre-calculate rounded positions to avoid repeated calculations
                const verticalLineCount = Math.floor((endX - startX) / gridSize) + 1;
                if (verticalLineCount > 0 && verticalLineCount <= maxLines) {
                    for (let i = 0; i <= verticalLineCount; i++) {
                        const x = startX + i * gridSize;
                        // Use precise rounding to avoid floating point artifacts
                        const xPos = Math.round(x * 10000) / 10000;
                        this.ctx.moveTo(xPos, viewBounds.top);
                        this.ctx.lineTo(xPos, viewBounds.bottom);
                    }
                }
                this.ctx.stroke();

                // Batch draw horizontal lines for better performance
                this.ctx.beginPath();
                const horizontalLineCount = Math.floor((endY - startY) / gridSize) + 1;
                if (horizontalLineCount > 0 && horizontalLineCount <= maxLines) {
                    for (let i = 0; i <= horizontalLineCount; i++) {
                        const y = startY + i * gridSize;
                        // Use precise rounding to avoid floating point artifacts
                        const yPos = Math.round(y * 10000) / 10000;
                        this.ctx.moveTo(viewBounds.left, yPos);
                        this.ctx.lineTo(viewBounds.right, yPos);
                    }
                }
                this.ctx.stroke();

                // Draw axes only for major grid with consistent visibility
                if (isMajor && Math.abs(gridSize - this.gridSize) < 0.01) {
                    // Explicitly set axis properties to ensure consistency
                    this.ctx.strokeStyle = '#999';
                    this.ctx.lineWidth = Math.max(1.5, Math.min(3.0, 2 * zoomInv));
                    this.ctx.lineCap = 'butt';
                    this.ctx.setLineDash([]); // Ensure solid lines for axes
                    this.ctx.globalAlpha = 1.0;

                    // X-axis
                    this.ctx.beginPath();
                    this.ctx.moveTo(viewBounds.left, 0);
                    this.ctx.lineTo(viewBounds.right, 0);
                    this.ctx.stroke();

                    // Y-axis
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, viewBounds.top);
                    this.ctx.lineTo(0, viewBounds.bottom);
                    this.ctx.stroke();
                }
            }

            drawPolygon(polygon, selected = false) {
                // Save context state before drawing polygon to ensure grid isn't affected
                this.ctx.save();

                const vertices = polygon.vertices;
                if (vertices.length < 2) {
                    this.ctx.restore();
                    return;
                }

                // Draw fill
                this.ctx.fillStyle = polygon.color + '33';
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                this.ctx.fill();

                // Draw stroke
                this.ctx.strokeStyle = selected ? '#333' : polygon.color;
                this.ctx.lineWidth = (selected ? 3 : 2) / this.zoom;
                this.ctx.stroke();

                // Draw vertices
                for (let i = 0; i < vertices.length; i++) {
                    const v = vertices[i];

                    // Normal vertex rendering - enhanced for better dragging visibility
                    let vertexSize = selected ? 8 : 4;
                    let vertexFill = selected ? '#fff' : polygon.color;
                    let vertexStroke = selected ? '#333' : polygon.color;

                    // Make vertex larger when it's being dragged
                    if (this.selectedVertex === v) {
                        vertexSize = selected ? 10 : 6;
                    }

                    this.ctx.fillStyle = vertexFill;
                    this.ctx.strokeStyle = vertexStroke;
                    this.ctx.lineWidth = 2 / this.zoom;

                    this.ctx.beginPath();
                    this.ctx.arc(v.x, v.y, vertexSize / this.zoom, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                }

                // Restore context state after drawing polygon
                this.ctx.restore();
            }

            /**
             * Professional AAA-Quality Slice Line Rendering
             * - No annoying red dots
             * - Smooth gradient line with glow effects
             * - Elegant visual feedback for valid/invalid states
             * - Animated slice preview
             */
            drawProfessionalSliceLine() {
                if (!this.splitLineStart || !this.splitLineEnd) return;

                this.ctx.save();

                const start = this.splitLineStart;
                const end = this.splitLineEnd;
                const isValid = this.isSplitValid(start, end);

                // Calculate line properties
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);

                // Skip if line is too short (just a click, no drag yet)
                if (length < 5 / this.zoom) {
                    this.ctx.restore();
                    return;
                }

                // Update animation phase for smooth effects
                this.sliceAnimationPhase = (this.sliceAnimationPhase + 0.05) % (Math.PI * 2);

                // Animate glow intensity on validity change
                const targetGlow = isValid ? 1 : 0.3;
                this.sliceGlowIntensity += (targetGlow - this.sliceGlowIntensity) * 0.15;

                // === LAYER 1: Outer Glow (soft, wide) ===
                if (isValid) {
                    this.ctx.save();
                    this.ctx.shadowColor = 'rgba(34, 197, 94, 0.6)'; // Green glow
                    this.ctx.shadowBlur = 20 / this.zoom * this.sliceGlowIntensity;
                    this.ctx.strokeStyle = 'rgba(34, 197, 94, 0.3)';
                    this.ctx.lineWidth = 8 / this.zoom;
                    this.ctx.lineCap = 'round';
                    this.ctx.beginPath();
                    this.ctx.moveTo(start.x, start.y);
                    this.ctx.lineTo(end.x, end.y);
                    this.ctx.stroke();
                    this.ctx.restore();
                }

                // === LAYER 2: Main Line with Gradient ===
                const gradient = this.ctx.createLinearGradient(start.x, start.y, end.x, end.y);

                if (isValid) {
                    // Valid: Vibrant green gradient
                    gradient.addColorStop(0, '#22c55e');    // Green 500
                    gradient.addColorStop(0.5, '#4ade80');  // Green 400
                    gradient.addColorStop(1, '#22c55e');    // Green 500
                } else {
                    // Invalid/Drawing: Subtle blue-gray gradient
                    gradient.addColorStop(0, '#64748b');    // Slate 500
                    gradient.addColorStop(0.5, '#94a3b8');  // Slate 400
                    gradient.addColorStop(1, '#64748b');    // Slate 500
                }

                this.ctx.strokeStyle = gradient;
                this.ctx.lineWidth = (isValid ? 4 : 3) / this.zoom;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.setLineDash([]);

                this.ctx.beginPath();
                this.ctx.moveTo(start.x, start.y);
                this.ctx.lineTo(end.x, end.y);
                this.ctx.stroke();

                // === LAYER 3: Inner highlight line (for depth) ===
                if (isValid) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.lineWidth = 1.5 / this.zoom;
                    this.ctx.beginPath();
                    this.ctx.moveTo(start.x, start.y);
                    this.ctx.lineTo(end.x, end.y);
                    this.ctx.stroke();
                }

                // === LAYER 4: Elegant endpoint indicators (NO RED DOTS) ===
                // Only show subtle indicators, not distracting circles
                if (isValid) {
                    // Valid: Small glowing diamonds at endpoints
                    this.drawSliceEndpoint(start, true);
                    this.drawSliceEndpoint(end, true);
                } else {
                    // Invalid: Very subtle indicators
                    this.drawSliceEndpoint(start, false);
                    this.drawSliceEndpoint(end, false);
                }

                // === LAYER 5: Animated "cutting" particles for valid slices ===
                if (isValid && length > 20 / this.zoom) {
                    this.drawSliceParticles(start, end, length);
                }

                // Track validity for haptic feedback
                if (isValid !== this.sliceLastValidState) {
                    this.sliceLastValidState = isValid;
                    // Could add haptic feedback here for mobile: navigator.vibrate?.(10);
                }

                this.ctx.restore();
            }

            /**
             * Draw elegant endpoint indicator (replaces ugly red dots)
             */
            drawSliceEndpoint(point, isValid) {
                const size = 6 / this.zoom;

                this.ctx.save();

                if (isValid) {
                    // Valid: Glowing green diamond
                    this.ctx.fillStyle = 'rgba(34, 197, 94, 0.9)';
                    this.ctx.shadowColor = 'rgba(34, 197, 94, 0.8)';
                    this.ctx.shadowBlur = 8 / this.zoom;
                } else {
                    // Invalid: Subtle gray circle
                    this.ctx.fillStyle = 'rgba(148, 163, 184, 0.6)';
                    this.ctx.shadowColor = 'transparent';
                    this.ctx.shadowBlur = 0;
                }

                // Draw diamond shape for valid, circle for invalid
                this.ctx.beginPath();
                if (isValid) {
                    // Diamond shape
                    this.ctx.moveTo(point.x, point.y - size);
                    this.ctx.lineTo(point.x + size * 0.7, point.y);
                    this.ctx.lineTo(point.x, point.y + size);
                    this.ctx.lineTo(point.x - size * 0.7, point.y);
                    this.ctx.closePath();
                } else {
                    // Small subtle circle
                    this.ctx.arc(point.x, point.y, size * 0.5, 0, Math.PI * 2);
                }
                this.ctx.fill();

                // Add white inner highlight for valid endpoints
                if (isValid) {
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, size * 0.3, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                this.ctx.restore();
            }

            /**
             * Draw animated particles along the slice line for visual feedback
             */
            drawSliceParticles(start, end, length) {
                const numParticles = Math.min(5, Math.floor(length * this.zoom / 50));
                const time = Date.now() / 1000;

                this.ctx.save();

                for (let i = 0; i < numParticles; i++) {
                    // Animate particle position along the line
                    const baseT = i / numParticles;
                    const animatedT = (baseT + time * 0.5) % 1;

                    const x = start.x + (end.x - start.x) * animatedT;
                    const y = start.y + (end.y - start.y) * animatedT;

                    // Fade in/out based on position
                    const alpha = Math.sin(animatedT * Math.PI) * 0.6;
                    const size = (2 + Math.sin(time * 3 + i) * 1) / this.zoom;

                    this.ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                this.ctx.restore();
            }

            drawVisualizers() {
                const poly = this.selectedPolygon;
                if (!poly || poly.vertices.length < 3) return;

                this.ctx.save();

                // Angles
                if (this.visualizers.has('angles')) {
                    this.ctx.font = `bold ${14 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';

                    for (let i = 0; i < poly.vertices.length; i++) {
                        const v1 = poly.vertices[i];
                        const v2 = poly.vertices[(i + 1) % poly.vertices.length];
                        const v3 = poly.vertices[(i + 2) % poly.vertices.length];

                        const a = this.distance(v2, v3); // Side from v2 to v3 (Adjacent 1)
                        const b = this.distance(v1, v3); // Side from v1 to v3 (Opposite to v2)
                        const c = this.distance(v1, v2); // Side from v1 to v2 (Adjacent 2)

                        // Law of Cosines for Angle at v2: bÂ² = aÂ² + cÂ² - 2ac cos(Angle)
                        // cos(Angle) = (aÂ² + cÂ² - bÂ²) / (2ac)
                        let numerator = a * a + c * c - b * b;
                        let denominator = 2 * a * c;

                        // Avoid division by zero
                        if (denominator === 0) continue;

                        let cosAngle = numerator / denominator;
                        // Clamp to [-1, 1] to handle float precision issues
                        cosAngle = Math.max(-1, Math.min(1, cosAngle));

                        const angle = Math.acos(cosAngle) * 180 / Math.PI;

                        // Calculate Bisector Vector for positioning
                        // Vector v2->v1
                        let dx1 = v1.x - v2.x;
                        let dy1 = v1.y - v2.y;
                        const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                        if (len1 > 0) { dx1 /= len1; dy1 /= len1; }

                        // Vector v2->v3
                        let dx3 = v3.x - v2.x;
                        let dy3 = v3.y - v2.y;
                        const len3 = Math.sqrt(dx3 * dx3 + dy3 * dy3);
                        if (len3 > 0) { dx3 /= len3; dy3 /= len3; }

                        // Bisector (Approximate inward direction for angle <= 180)
                        let bx = dx1 + dx3;
                        let by = dy1 + dy3;
                        const bLen = Math.sqrt(bx * bx + by * by);
                        if (bLen > 0) { bx /= bLen; by /= bLen; }

                        // Offset distance (Inward)
                        const offset = 35 / this.zoom;
                        const labelX = v2.x + bx * offset;
                        const labelY = v2.y + by * offset;

                        // Draw Badge
                        const text = `${angle.toFixed(0)}Â°`;
                        // Fixed radius circle usually fits 2-3 digits well enough at this font size
                        // Radius 12 fits nicely
                        this.ctx.beginPath();
                        this.ctx.arc(labelX, labelY, 13 / this.zoom, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        this.ctx.fill();
                        this.ctx.lineWidth = 1 / this.zoom;
                        this.ctx.strokeStyle = '#ff6b6b';
                        this.ctx.stroke();

                        this.ctx.fillStyle = '#ff6b6b';
                        this.ctx.fillText(text, labelX, labelY);
                    }
                }

                // Medians & Centroid (for triangles)
                if (this.visualizers.has('medians') && poly.vertices.length === 3) {
                    this.ctx.strokeStyle = '#3b82f6';
                    this.ctx.lineWidth = 1 / this.zoom;
                    this.ctx.setLineDash([4 / this.zoom, 4 / this.zoom]);

                    const centroid = {
                        x: (poly.vertices[0].x + poly.vertices[1].x + poly.vertices[2].x) / 3,
                        y: (poly.vertices[0].y + poly.vertices[1].y + poly.vertices[2].y) / 3
                    };

                    for (let i = 0; i < 3; i++) {
                        const v = poly.vertices[i];
                        const opposite1 = poly.vertices[(i + 1) % 3];
                        const opposite2 = poly.vertices[(i + 2) % 3];
                        const midpoint = {
                            x: (opposite1.x + opposite2.x) / 2,
                            y: (opposite1.y + opposite2.y) / 2
                        };

                        this.ctx.beginPath();
                        this.ctx.moveTo(v.x, v.y);
                        this.ctx.lineTo(midpoint.x, midpoint.y);
                        this.ctx.stroke();
                    }

                    this.ctx.setLineDash([]);
                    this.ctx.fillStyle = '#3b82f6';
                    this.ctx.beginPath();
                    this.ctx.arc(centroid.x, centroid.y, 5 / this.zoom, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Altitudes & Orthocenter (for triangles only)
                if (this.visualizers.has('altitudes') && poly.vertices.length === 3) {
                    this.ctx.strokeStyle = '#ef4444'; // Red
                    this.ctx.lineWidth = 1.5 / this.zoom;
                    this.ctx.setLineDash([5 / this.zoom, 3 / this.zoom]);

                    const altitudes = [];
                    const vertices = poly.vertices;

                    // Safety check: ensure we have exactly 3 valid vertices
                    if (vertices.length !== 3) {
                        this.ctx.setLineDash([]);
                        this.ctx.restore();
                        return;
                    }

                    // Calculate all three altitudes
                    for (let i = 0; i < 3; i++) {
                        const vertex = vertices[i];
                        const opposite1 = vertices[(i + 1) % 3];
                        const opposite2 = vertices[(i + 2) % 3];

                        // Safety checks
                        if (!vertex || !opposite1 || !opposite2) continue;
                        if (!isFinite(vertex.x) || !isFinite(vertex.y) ||
                            !isFinite(opposite1.x) || !isFinite(opposite1.y) ||
                            !isFinite(opposite2.x) || !isFinite(opposite2.y)) continue;

                        // Line from opposite1 to opposite2
                        const dx = opposite2.x - opposite1.x;
                        const dy = opposite2.y - opposite1.y;
                        const lineLength = Math.sqrt(dx * dx + dy * dy);

                        if (lineLength < 1e-10) continue; // Avoid division by zero

                        // Calculate projection of vertex onto the opposite side
                        const t = ((vertex.x - opposite1.x) * dx + (vertex.y - opposite1.y) * dy) / (lineLength * lineLength);
                        const foot = {
                            x: opposite1.x + t * dx,
                            y: opposite1.y + t * dy
                        };

                        // Draw altitude line from vertex to foot
                        this.ctx.beginPath();
                        this.ctx.moveTo(vertex.x, vertex.y);
                        this.ctx.lineTo(foot.x, foot.y);
                        this.ctx.stroke();

                        altitudes.push({ vertex, foot });
                    }

                    // Calculate orthocenter (intersection of altitudes)
                    // For triangle with vertices A, B, C:
                    // Orthocenter is intersection of altitudes from A and B
                    if (altitudes.length >= 2) {
                        const alt1 = altitudes[0];
                        const alt2 = altitudes[1];

                        // Line 1: from alt1.vertex to alt1.foot
                        const dx1 = alt1.foot.x - alt1.vertex.x;
                        const dy1 = alt1.foot.y - alt1.vertex.y;
                        const m1 = dx1 !== 0 ? dy1 / dx1 : Infinity;
                        const b1 = m1 !== Infinity ? alt1.vertex.y - m1 * alt1.vertex.x : alt1.vertex.x;

                        // Line 2: from alt2.vertex to alt2.foot
                        const dx2 = alt2.foot.x - alt2.vertex.x;
                        const dy2 = alt2.foot.y - alt2.vertex.y;
                        const m2 = dx2 !== 0 ? dy2 / dx2 : Infinity;
                        const b2 = m2 !== Infinity ? alt2.vertex.y - m2 * alt2.vertex.x : alt2.vertex.x;

                        let orthocenter = null;

                        if (m1 === Infinity && m2 === Infinity) {
                            // Both vertical - parallel, no intersection
                            orthocenter = null;
                        } else if (m1 === Infinity) {
                            // Line 1 is vertical
                            const x = b1;
                            const y = m2 * x + b2;
                            orthocenter = { x, y };
                        } else if (m2 === Infinity) {
                            // Line 2 is vertical
                            const x = b2;
                            const y = m1 * x + b1;
                            orthocenter = { x, y };
                        } else {
                            // Both have slopes
                            const x = (b2 - b1) / (m1 - m2);
                            const y = m1 * x + b1;
                            orthocenter = { x, y };
                        }

                        // Draw orthocenter point
                        if (orthocenter && isFinite(orthocenter.x) && isFinite(orthocenter.y)) {
                            this.ctx.setLineDash([]);
                            this.ctx.fillStyle = '#ef4444';
                            this.ctx.beginPath();
                            this.ctx.arc(orthocenter.x, orthocenter.y, 6 / this.zoom, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = 1.5 / this.zoom;
                            this.ctx.stroke();
                        }
                    }

                    this.ctx.setLineDash([]);
                }

                // Perpendicular Bisectors (for triangles and other polygons)
                if (this.visualizers.has('bisectors')) {
                    this.ctx.strokeStyle = '#10b981'; // Green
                    this.ctx.lineWidth = 1.5 / this.zoom;
                    this.ctx.setLineDash([5 / this.zoom, 3 / this.zoom]);

                    const vertices = poly.vertices;
                    const bisectors = [];

                    // Safety check: need at least 3 vertices
                    if (vertices.length < 3) {
                        this.ctx.setLineDash([]);
                        this.ctx.restore();
                        return;
                    }

                    // Calculate perpendicular bisector for each side
                    for (let i = 0; i < vertices.length; i++) {
                        const v1 = vertices[i];
                        const v2 = vertices[(i + 1) % vertices.length];

                        // Safety checks
                        if (!v1 || !v2) continue;
                        if (!isFinite(v1.x) || !isFinite(v1.y) ||
                            !isFinite(v2.x) || !isFinite(v2.y)) continue;

                        // Midpoint of the side
                        const midpoint = {
                            x: (v1.x + v2.x) / 2,
                            y: (v1.y + v2.y) / 2
                        };

                        // Direction vector of the side
                        const dx = v2.x - v1.x;
                        const dy = v2.y - v1.y;
                        const sideLength = Math.sqrt(dx * dx + dy * dy);

                        if (sideLength < 1e-10) continue; // Avoid division by zero

                        // Perpendicular direction (rotate 90 degrees)
                        const perpDx = -dy;
                        const perpDy = dx;

                        // Normalize perpendicular vector
                        const perpLength = Math.sqrt(perpDx * perpDx + perpDy * perpDy);
                        if (perpLength === 0) continue;

                        const perpNormX = perpDx / perpLength;
                        const perpNormY = perpDy / perpLength;

                        // Calculate centroid to determine which direction to extend
                        let cx = 0, cy = 0;
                        for (let v of vertices) {
                            cx += v.x;
                            cy += v.y;
                        }
                        cx /= vertices.length;
                        cy /= vertices.length;

                        // Extend bisector in both directions (long enough to be visible)
                        const extendLength = Math.max(200, sideLength * 2) / this.zoom;
                        const startX = midpoint.x - perpNormX * extendLength;
                        const startY = midpoint.y - perpNormY * extendLength;
                        const endX = midpoint.x + perpNormX * extendLength;
                        const endY = midpoint.y + perpNormY * extendLength;

                        // Draw bisector line
                        this.ctx.beginPath();
                        this.ctx.moveTo(startX, startY);
                        this.ctx.lineTo(endX, endY);
                        this.ctx.stroke();

                        bisectors.push({ midpoint, perpNormX, perpNormY });
                    }

                    // For triangles, find and draw circumcenter (intersection of perpendicular bisectors)
                    if (vertices.length === 3 && bisectors.length >= 2) {
                        const bis1 = bisectors[0];
                        const bis2 = bisectors[1];

                        // Line 1: through bis1.midpoint with direction bis1.perpNormX, bis1.perpNormY
                        // Parametric: p = bis1.midpoint + t * (bis1.perpNormX, bis1.perpNormY)
                        // Convert to ax + by = c form
                        const a1 = -bis1.perpNormY;
                        const b1 = bis1.perpNormX;
                        const c1 = a1 * bis1.midpoint.x + b1 * bis1.midpoint.y;

                        // Line 2: through bis2.midpoint with direction bis2.perpNormX, bis2.perpNormY
                        const a2 = -bis2.perpNormY;
                        const b2 = bis2.perpNormX;
                        const c2 = a2 * bis2.midpoint.x + b2 * bis2.midpoint.y;

                        // Solve system: a1*x + b1*y = c1, a2*x + b2*y = c2
                        const det = a1 * b2 - a2 * b1;

                        if (Math.abs(det) > 1e-10) {
                            const circumcenterX = (c1 * b2 - c2 * b1) / det;
                            const circumcenterY = (a1 * c2 - a2 * c1) / det;

                            if (isFinite(circumcenterX) && isFinite(circumcenterY)) {
                                // Draw circumcenter
                                this.ctx.setLineDash([]);
                                this.ctx.fillStyle = '#10b981';
                                this.ctx.beginPath();
                                this.ctx.arc(circumcenterX, circumcenterY, 6 / this.zoom, 0, Math.PI * 2);
                                this.ctx.fill();
                                this.ctx.strokeStyle = '#ffffff';
                                this.ctx.lineWidth = 1.5 / this.zoom;
                                this.ctx.stroke();
                            }
                        }
                    }

                    this.ctx.setLineDash([]);
                }

                // Diagonals (for polygons with more than 3 vertices)
                if (this.visualizers.has('diagonals') && poly.vertices.length > 3) {
                    this.ctx.strokeStyle = '#a855f7'; // Purple
                    this.ctx.lineWidth = 1 / this.zoom;
                    this.ctx.setLineDash([4 / this.zoom, 4 / this.zoom]);

                    const vertices = poly.vertices;

                    // Draw all diagonals: connect vertex i to vertex j where j is at least 2 positions away
                    // This ensures we don't draw edges (adjacent vertices)
                    for (let i = 0; i < vertices.length; i++) {
                        for (let j = i + 2; j < vertices.length; j++) {
                            // Skip the edge case where last vertex connects to first (that's an edge, not a diagonal)
                            if (j === vertices.length - 1 && i === 0) continue;

                            // Safety check: ensure vertices are valid
                            if (!vertices[i] || !vertices[j]) continue;
                            if (!isFinite(vertices[i].x) || !isFinite(vertices[i].y) ||
                                !isFinite(vertices[j].x) || !isFinite(vertices[j].y)) continue;

                            this.ctx.beginPath();
                            this.ctx.moveTo(vertices[i].x, vertices[i].y);
                            this.ctx.lineTo(vertices[j].x, vertices[j].y);
                            this.ctx.stroke();
                        }
                    }

                    this.ctx.setLineDash([]);
                }

                // Show Vertices (ABC points)
                if (this.visualizers.has('vertices')) {
                    this.ctx.font = `bold ${16 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';

                    // Calculate centroid
                    let cx = 0, cy = 0;
                    if (poly.vertices.length > 0) {
                        for (let v of poly.vertices) { cx += v.x; cy += v.y; }
                        cx /= poly.vertices.length;
                        cy /= poly.vertices.length;
                    }

                    const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                    for (let i = 0; i < poly.vertices.length; i++) {
                        const v = poly.vertices[i];
                        const letter = letters[i % letters.length];

                        // Calculate outward direction
                        let dx = v.x - cx;
                        let dy = v.y - cy;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        if (len > 0) {
                            dx /= len;
                            dy /= len;
                        }

                        // Offset: Vertex Radius (approx 5) + padding
                        const dist = 20 / this.zoom;
                        const labelX = v.x + dx * dist;
                        const labelY = v.y + dy * dist;

                        // Draw Background Badge (White Circle)
                        this.ctx.beginPath();
                        this.ctx.arc(labelX, labelY, 10 / this.zoom, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        this.ctx.fill();
                        this.ctx.lineWidth = 1 / this.zoom;
                        this.ctx.strokeStyle = '#10b981';
                        this.ctx.stroke();

                        // Draw Letter
                        this.ctx.fillStyle = '#10b981';
                        this.ctx.fillText(letter, labelX, labelY);
                    }
                }

                // Show Perimeters
                if (this.visualizers.has('perimeters')) {
                    this.ctx.font = `${14 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.lineWidth = 1.5 / this.zoom;
                    this.ctx.strokeStyle = '#0d9488'; // Teal
                    this.ctx.fillStyle = '#0d9488'; // Teal

                    // Calculate centroid for outward direction check
                    let cx = 0, cy = 0;
                    for (let v of poly.vertices) { cx += v.x; cy += v.y; }
                    cx /= poly.vertices.length;
                    cy /= poly.vertices.length;

                    for (let i = 0; i < poly.vertices.length; i++) {
                        const v1 = poly.vertices[i];
                        const v2 = poly.vertices[(i + 1) % poly.vertices.length];

                        // Calculate grid length
                        const dx = v2.x - v1.x;
                        const dy = v2.y - v1.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const distance = len / this.gridSize;

                        // Calculate offset vector (perpendicular to edge)
                        const angle = Math.atan2(dy, dx);
                        const offsetX = Math.sin(angle) * (15 / this.zoom);
                        const offsetY = -Math.cos(angle) * (15 / this.zoom);

                        const midX = (v1.x + v2.x) / 2;
                        const midY = (v1.y + v2.y) / 2;

                        // Check if offset is outward or inward compared to centroid
                        const distOut = (midX + offsetX - cx) ** 2 + (midY + offsetY - cy) ** 2;
                        const distIn = (midX - offsetX - cx) ** 2 + (midY - offsetY - cy) ** 2;

                        const actualOffsetX = distOut > distIn ? offsetX : -offsetX;
                        const actualOffsetY = distOut > distIn ? offsetY : -offsetY;

                        // Draw Bracket
                        this.ctx.beginPath();
                        // Main line
                        this.ctx.moveTo(v1.x + actualOffsetX, v1.y + actualOffsetY);
                        this.ctx.lineTo(v2.x + actualOffsetX, v2.y + actualOffsetY);

                        // End caps (small ticks)
                        const tickX = Math.cos(angle) * (4 / this.zoom);
                        const tickY = Math.sin(angle) * (4 / this.zoom);

                        this.ctx.moveTo(v1.x + actualOffsetX + tickX, v1.y + actualOffsetY + tickY);
                        this.ctx.lineTo(v1.x + actualOffsetX - tickX, v1.y + actualOffsetY - tickY);

                        this.ctx.moveTo(v2.x + actualOffsetX + tickX, v2.y + actualOffsetY + tickY);
                        this.ctx.lineTo(v2.x + actualOffsetX - tickX, v2.y + actualOffsetY - tickY);

                        this.ctx.stroke();

                        // Label
                        this.ctx.fillText(`${distance.toFixed(1)}`, midX + actualOffsetX * 1.8, midY + actualOffsetY * 1.8);
                    }
                }

                // Show Base & Height
                if (this.visualizers.has('baseHeight')) {
                    this.ctx.font = `${14 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.lineWidth = 1.5 / this.zoom;

                    const vertices = poly.vertices;

                    if (vertices.length === 3) {
                        // Triangle Logic: Find the "best" base (closest to horizontal bottom)
                        let bestSideIndex = -1;
                        let maxHorizontalScore = -Infinity;

                        for (let i = 0; i < 3; i++) {
                            const v1 = vertices[i];
                            const v2 = vertices[(i + 1) % 3];
                            const dx = Math.abs(v2.x - v1.x);
                            const dy = Math.abs(v2.y - v1.y);
                            const length = Math.sqrt(dx * dx + dy * dy);

                            // Score: Prefer horizontal (small dy) and lower (large y)
                            // We weigh horizontal alignment heavily
                            const horizontalness = dx / (length + 0.001); // 0 to 1
                            const avgY = (v1.y + v2.y) / 2;

                            // Simple heuristic: Horizontalness is king, then lower Y
                            const score = horizontalness * 1000 + avgY;

                            if (score > maxHorizontalScore) {
                                maxHorizontalScore = score;
                                bestSideIndex = i;
                            }
                        }

                        const i = bestSideIndex;
                        const baseV1 = vertices[i];
                        const baseV2 = vertices[(i + 1) % 3];
                        const apex = vertices[(i + 2) % 3];

                        // Calculate geometric base length
                        const baseLength = this.distance(baseV1, baseV2) / this.gridSize;

                        // Calculate geometric height (distance from apex to base line)
                        // Area = 0.5 * base * height => Height = 2 * Area / Base
                        // Use signed area formula for polygon area
                        const area = Math.abs(poly.getArea());
                        // Wait, poly.getArea() returns area in square grid units (roughly), 
                        // let's trust geometric calculation

                        // Recalculate physical area using coordinates for precision
                        const physicalArea = Math.abs((baseV1.x * (baseV2.y - apex.y) + baseV2.x * (apex.y - baseV1.y) + apex.x * (baseV1.y - baseV2.y)) / 2);
                        const physicalBase = this.distance(baseV1, baseV2);
                        const physicalHeight = (2 * physicalArea) / physicalBase;
                        const heightLength = physicalHeight / this.gridSize;

                        // Draw Base Bracket
                        this.ctx.strokeStyle = '#2563eb'; // Blue for Base
                        this.ctx.fillStyle = '#2563eb';

                        // Offset for bracket
                        const angle = Math.atan2(baseV2.y - baseV1.y, baseV2.x - baseV1.x);
                        const offsetX = Math.sin(angle) * (20 / this.zoom);
                        const offsetY = -Math.cos(angle) * (20 / this.zoom);

                        // If offset points *into* the triangle, flip it
                        // Check midpoint + offset vs centroid
                        const midX = (baseV1.x + baseV2.x) / 2;
                        const midY = (baseV1.y + baseV2.y) / 2;
                        const centroidX = (baseV1.x + baseV2.x + apex.x) / 3;
                        const centroidY = (baseV1.y + baseV2.y + apex.y) / 3;

                        const valOriginal = (midX + offsetX - centroidX) ** 2 + (midY + offsetY - centroidY) ** 2;
                        const valFlipped = (midX - offsetX - centroidX) ** 2 + (midY - offsetY - centroidY) ** 2;

                        const actualOffsetX = valOriginal > valFlipped ? offsetX : -offsetX;
                        const actualOffsetY = valOriginal > valFlipped ? offsetY : -offsetY;

                        // Draw Bracket Line
                        this.ctx.beginPath();
                        this.ctx.moveTo(baseV1.x + actualOffsetX, baseV1.y + actualOffsetY);
                        this.ctx.lineTo(baseV2.x + actualOffsetX, baseV2.y + actualOffsetY);
                        this.ctx.stroke();

                        // Label Base
                        this.ctx.fillText(`b = ${baseLength.toFixed(1)}`, midX + actualOffsetX * 1.5, midY + actualOffsetY * 1.5);


                        // Draw Height Line
                        this.ctx.strokeStyle = '#dc2626'; // Red for Height
                        this.ctx.fillStyle = '#dc2626';
                        this.ctx.setLineDash([5 / this.zoom, 3 / this.zoom]);

                        // Project apex onto base line
                        // Line defined by baseV1 + t * (baseV2 - baseV1)
                        const dx = baseV2.x - baseV1.x;
                        const dy = baseV2.y - baseV1.y;
                        const t = ((apex.x - baseV1.x) * dx + (apex.y - baseV1.y) * dy) / (dx * dx + dy * dy);

                        const projX = baseV1.x + t * dx;
                        const projY = baseV1.y + t * dy;

                        this.ctx.beginPath();
                        this.ctx.moveTo(apex.x, apex.y);
                        this.ctx.lineTo(projX, projY);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);

                        // Label Height
                        const hMidX = (apex.x + projX) / 2;
                        const hMidY = (apex.y + projY) / 2;
                        this.ctx.fillText(`h = ${heightLength.toFixed(1)}`, hMidX + 10 / this.zoom, hMidY);

                        // Draw Right Angle mark at projection
                        const size = 10 / this.zoom;
                        // Need vector along base line
                        const baseLen = Math.sqrt(dx * dx + dy * dy);
                        const ux = dx / baseLen;
                        const uy = dy / baseLen;
                        // Vector along height line
                        const hx = apex.x - projX;
                        const hy = apex.y - projY;
                        // Perpendicular check not strictly needed for drawing box, just use base direction

                        // We draw a small box at projX,projY aligned with base
                        // This is tricky on general angles, skipping for simplicity or just drawing a dot
                        this.ctx.beginPath();
                        this.ctx.arc(projX, projY, 3 / this.zoom, 0, Math.PI * 2);
                        this.ctx.fill();

                    } else {
                        // Bounding Box Logic for other polygons
                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                        vertices.forEach(v => {
                            minX = Math.min(minX, v.x);
                            maxX = Math.max(maxX, v.x);
                            minY = Math.min(minY, v.y);
                            maxY = Math.max(maxY, v.y);
                        });

                        const width = (maxX - minX) / this.gridSize;
                        const height = (maxY - minY) / this.gridSize;

                        this.ctx.strokeStyle = '#2563eb';
                        this.ctx.fillStyle = '#2563eb';

                        // Width label (Bottom)
                        this.ctx.beginPath();
                        this.ctx.moveTo(minX, maxY + 20 / this.zoom);
                        this.ctx.lineTo(maxX, maxY + 20 / this.zoom);
                        this.ctx.stroke();
                        this.ctx.fillText(`w = ${width.toFixed(1)}`, (minX + maxX) / 2, maxY + 35 / this.zoom);

                        this.ctx.strokeStyle = '#dc2626';
                        this.ctx.fillStyle = '#dc2626';

                        // Height label (Right)
                        this.ctx.beginPath();
                        this.ctx.moveTo(maxX + 20 / this.zoom, minY);
                        this.ctx.lineTo(maxX + 20 / this.zoom, maxY);
                        this.ctx.stroke();
                        this.ctx.fillText(`h = ${height.toFixed(1)}`, maxX + 35 / this.zoom, (minY + maxY) / 2);
                    }
                }

                this.ctx.restore();
            }

            getMouseWorldPos() {
                // Get current mouse position in world coordinates
                // This is a simplified version - would need actual mouse tracking
                return null;
            }

            // Utility functions
            isFlickGesture(distancePx, durationMs, inputType = 'mouse') {
                const speedPxPerMs = distancePx / Math.max(1, durationMs);
                const isTouch = inputType === 'touch';

                const minDistance = isTouch ? 34 : 42;
                const minSpeed = isTouch ? 0.60 : 0.70;
                const burstDistance = isTouch ? 80 : 90;
                const burstDuration = isTouch ? 240 : 220;

                if (distancePx < minDistance) return false;
                if (speedPxPerMs >= minSpeed) return true;
                if (distancePx >= burstDistance && durationMs <= burstDuration) return true;
                return false;
            }

            scheduleSplitPreviewRender() {
                if (this.splitPreviewRenderPending) return;
                this.splitPreviewRenderPending = true;
                requestAnimationFrame(() => {
                    this.splitPreviewRenderPending = false;
                    this.updateSplitExecuteButtonState();
                    this.render(true);
                });
            }

            setTool(tool) {

                document.querySelectorAll('[data-tool]').forEach(btn => {
                    if (btn.dataset.tool === tool) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                this.currentTool = tool;
                this.updateCursor();
                this.render();
            }



            togglePolygonVisibility(index) {
                if (this.polygons[index]) {
                    this.polygons[index].visible = !this.polygons[index].visible;
                    this.saveHistory();
                    this.scheduleSplitPreviewRender();
                    this.updateLayers();
                }
            }

            deletePolygon(index) {
                if (this.polygons[index]) {
                    if (this.selectedPolygon === this.polygons[index]) {
                        this.selectedPolygon = null;
                    }
                    this.polygons.splice(index, 1);
                    this.saveHistory();
                    this.updateProperties();
                    this.scheduleSplitPreviewRender();
                    this.render();
                }
            }

            deleteSelected() {
                if (this.selectedPolygon) {
                    const index = this.polygons.indexOf(this.selectedPolygon);
                    if (index !== -1) {
                        this.deletePolygon(index);
                    }
                }
            }

            cancelCurrentAction() {
                this.isDragging = false;
                this.selectedVertex = null;
                this.dragStart = null;
                this.render();
            }

            // History management
            saveHistory() {
                if (this.pruneSamplePolygonForGame()) {
                    this.updateLayers();
                    this.updateProperties();
                }
                const state = JSON.stringify(this.polygons.map(p => ({
                    vertices: p.vertices,
                    color: p.color,
                    name: p.name,
                    visible: p.visible
                })));

                // Avoid redundant saves if state hasn't changed
                if (this.historyIndex >= 0 && state === this.history[this.historyIndex]) {
                    return;
                }

                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(state);
                this.historyIndex++;

                // Limit history size
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.cancelCurrentAction();
                    this.historyIndex--;
                    this.loadState(this.history[this.historyIndex]);

                    // Update UI to reflect undo
                    this.updateProperties();
                    this.updateLayers();
                    this.markGridForRedraw();
                    // CRITICAL: Force render to ensure canvas reflects the undone state
                    this.render(true);
                } else {
                    console.log('Nothing to undo');
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.cancelCurrentAction();
                    this.historyIndex++;
                    this.loadState(this.history[this.historyIndex]);

                    // Update UI to reflect redo
                    this.updateProperties();
                    this.updateLayers();
                    this.markGridForRedraw();
                    // CRITICAL: Force render to ensure canvas reflects the redone state
                    this.render(true);
                } else {
                    console.log('Nothing to redo');
                }
            }

            loadState(state) {
                try {
                    const isGameModeActive = this.isGameModeActive();
                    // Store current selection info to restore it if possible
                    const selectedName = this.selectedPolygon ? this.selectedPolygon.name : null;
                    const selectedIndex = this.selectedPolygon ? this.polygons.indexOf(this.selectedPolygon) : -1;

                    const data = JSON.parse(state);

                    // Validate parsed data
                    if (!Array.isArray(data)) {
                        console.error('Invalid state data - not an array');
                        return;
                    }

                    // Recreate polygons from state
                    const restoredPolygons = data.map(p => {
                        if (!p || !p.vertices || !Array.isArray(p.vertices) || p.vertices.length < 3) {
                            console.warn('Invalid polygon in state, skipping', p);
                            return null;
                        }
                        const poly = new Polygon(p.vertices, p.color || '#667eea');
                        poly.name = p.name || 'Polygon';
                        poly.visible = p.visible !== false; // Default to visible
                        return poly;
                    }).filter(p => p !== null); // Remove any null entries

                    // In game mode, prevent restoring the default triangle from history
                    this.polygons = isGameModeActive
                        ? restoredPolygons.filter(p => p.name !== 'Triangle 1')
                        : restoredPolygons;

                    // Restore selection by name first (more reliable), then by index
                    if (selectedName) {
                        const polyByName = this.polygons.find(p => p.name === selectedName);
                        if (polyByName) {
                            this.selectedPolygon = polyByName;
                        } else if (selectedIndex >= 0 && selectedIndex < this.polygons.length) {
                            this.selectedPolygon = this.polygons[selectedIndex];
                        } else {
                            this.selectedPolygon = null;
                        }
                    } else if (selectedIndex >= 0 && selectedIndex < this.polygons.length) {
                        this.selectedPolygon = this.polygons[selectedIndex];
                    } else {
                        this.selectedPolygon = null;
                    }

                    // Clear any invalid selections
                    if (this.selectedPolygon && !this.polygons.includes(this.selectedPolygon)) {
                        this.selectedPolygon = null;
                        this.selectedVertex = null;
                    }

                    this.updateProperties();
                    this.updateLayers();
                    this.markGridForRedraw();
                    // Force render to ensure canvas is updated immediately
                    this.render(true);
                } catch (e) {
                    console.error('Error loading state:', e);
                    // Don't crash - just log the error
                }
            }

            // Zoom functions
            zoomIn() {
                this.zoom = Math.min(5, this.zoom * 1.2);
                this.gridNeedsRedraw = true;
                this.lastGridState = null; // Force grid state recalculation
                this.render();
            }

            zoomOut() {
                this.zoom = Math.max(0.1, this.zoom / 1.2);
                this.gridNeedsRedraw = true;
                this.lastGridState = null; // Force grid state recalculation
                this.render();
            }

            zoomReset() {
                this.zoom = 1;
                this.pan = { x: 0, y: 0 };
                this.gridNeedsRedraw = true;
                this.lastGridState = null; // Force grid state recalculation
                this.render();
            }

            panByDirection(direction) {
                const step = Math.max(48, Math.min(120, this.gridSize * 3));
                let dx = 0;
                let dy = 0;

                if (direction === 'up') dy = step;
                if (direction === 'down') dy = -step;
                if (direction === 'left') dx = step;
                if (direction === 'right') dx = -step;

                this.smoothPanBy(dx, dy, 150);
            }

            smoothPanBy(deltaX, deltaY, duration = 150) {
                if (this.panAnimationFrameId) {
                    cancelAnimationFrame(this.panAnimationFrameId);
                    this.panAnimationFrameId = null;
                }

                const startPanX = this.pan.x;
                const startPanY = this.pan.y;
                const startTime = performance.now();

                const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

                const animate = (now) => {
                    const elapsed = now - startTime;
                    const t = Math.min(1, elapsed / duration);
                    const eased = easeOutCubic(t);

                    this.pan.x = startPanX + deltaX * eased;
                    this.pan.y = startPanY + deltaY * eased;
                    this.gridNeedsRedraw = true;
                    this.lastGridState = null;
                    this.render(true);

                    if (t < 1) {
                        this.panAnimationFrameId = requestAnimationFrame(animate);
                    } else {
                        this.panAnimationFrameId = null;
                    }
                };

                this.panAnimationFrameId = requestAnimationFrame(animate);
            }

            // Fullscreen functionality
            toggleFullscreen() {
                const element = document.documentElement;
                const fullscreenBtn = document.getElementById('fullscreenToggle');

                // Check if currently in fullscreen
                const isFullscreen = !!(document.fullscreenElement ||
                    document.webkitFullscreenElement ||
                    document.mozFullScreenElement ||
                    document.msFullscreenElement);

                if (!isFullscreen) {
                    // Enter fullscreen
                    if (element.requestFullscreen) {
                        element.requestFullscreen().catch(err => {
                            console.error('Error entering fullscreen:', err);
                        });
                    } else if (element.webkitRequestFullscreen) {
                        element.webkitRequestFullscreen();
                    } else if (element.mozRequestFullScreen) {
                        element.mozRequestFullScreen();
                    } else if (element.msRequestFullscreen) {
                        element.msRequestFullscreen();
                    }
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen().catch(err => {
                            console.error('Error exiting fullscreen:', err);
                        });
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }
            }

            handleFullscreenChange() {
                const fullscreenBtn = document.getElementById('fullscreenToggle');
                const isFullscreen = !!(document.fullscreenElement ||
                    document.webkitFullscreenElement ||
                    document.mozFullScreenElement ||
                    document.msFullscreenElement);

                if (fullscreenBtn) {
                    if (isFullscreen) {
                        fullscreenBtn.classList.add('active');
                        fullscreenBtn.textContent = 'â¤¡'; // Exit fullscreen icon
                        fullscreenBtn.title = 'Exit Fullscreen';
                        document.body.classList.add('fullscreen-active');
                    } else {
                        fullscreenBtn.classList.remove('active');
                        fullscreenBtn.textContent = 'â¤¢'; // Enter fullscreen icon
                        fullscreenBtn.title = 'Enter Fullscreen';
                        document.body.classList.remove('fullscreen-active');
                    }
                }

                // Resize canvas after a short delay to ensure dimensions are updated
                setTimeout(() => {
                    this.resizeCanvas();
                    // Re-center view on triangle if it exists
                    if (this.polygons.length > 0 && this.polygons[0].name === 'Triangle 1') {
                        const triangleCenter = this.getPolygonCenter(this.polygons[0]);
                        this.centerViewOn(triangleCenter.x, triangleCenter.y);
                    }
                    this.render();
                }, 100);
            }

            // Save/Load
            save() {
                const data = {
                    polygons: this.polygons.map(p => ({
                        vertices: p.vertices,
                        color: p.color,
                        name: p.name
                    }))
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'polygon-fun.json';
                a.click();

                URL.revokeObjectURL(url);
            }

            load() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';

                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            this.polygons = data.polygons.map(p => {
                                const poly = new Polygon(p.vertices, p.color);
                                poly.name = p.name;
                                return poly;
                            });

                            this.selectedPolygon = null;
                            this.saveHistory();
                            this.updateProperties();
                            this.updateLayers();
                            this.render();
                        } catch (error) {
                            alert('Error loading file: ' + error.message);
                        }
                    };

                    reader.readAsText(file);
                };

                input.click();
            }

            reset() {
                const modal = document.getElementById('resetModal');
                if (modal) {
                    modal.style.display = 'flex';
                }
            }

            executeReset() {
                // Exit any active modes
                if (this.combineMode) this.exitCombineMode();
                if (this.splitMode) this.exitSplitMode();

                // switch to select tool to ensure UI is consistent
                this.setTool('select');

                this.polygons = [];
                this.selectedPolygon = null;
                this.selectedVertex = null;
                this.history = [];
                this.historyIndex = -1;
                this.zoom = 1;
                this.pan = { x: 0, y: 0 };

                if (!this.isGameModeActive()) {
                    this.createSamplePolygon();
                }
                this.updateProperties(); // Clear properties panel
                this.updateLayers();
                this.render();
            }

            highlightConcept(concept) {
                // Visual feedback when visualizer concepts are clicked
                console.log('Highlighting concept:', concept);
            }
        }

        // Polygon class
        class Polygon {
            constructor(vertices = [], color = '#667eea') {
                // Always create new point objects to ensure independence from other polygons
                this.vertices = vertices.map(v => ({ x: v.x, y: v.y }));
                this.color = color;
                this.name = 'Polygon';
                this.visible = true;
            }

            containsPoint(point) {
                let inside = false;
                const vertices = this.vertices;

                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x, yi = vertices[i].y;
                    const xj = vertices[j].x, yj = vertices[j].y;

                    const intersect = ((yi > point.y) !== (yj > point.y)) &&
                        (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);

                    if (intersect) inside = !inside;
                }

                return inside;
            }

            getArea() {
                // Shoelace formula
                let area = 0;
                const n = this.vertices.length;

                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    area += this.vertices[i].x * this.vertices[j].y;
                    area -= this.vertices[j].x * this.vertices[i].y;
                }

                return Math.abs(area / 2);
            }

            getPerimeter() {
                let perimeter = 0;
                const n = this.vertices.length;

                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    const dx = this.vertices[j].x - this.vertices[i].x;
                    const dy = this.vertices[j].y - this.vertices[i].y;
                    perimeter += Math.sqrt(dx * dx + dy * dy);
                }

                return perimeter;
            }

            move(dx, dy) {
                // Create new objects for vertices to break any shared references
                this.vertices = this.vertices.map(v => ({
                    x: v.x + dx,
                    y: v.y + dy
                }));
            }
        }

        // Mobile and Tablet menu toggle functionality
        function toggleMobileSidebar(sidebar) {
            const deviceInfo = deviceDetector ? deviceDetector.getInfo() : { isMobile: false, isTablet: false };
            const isMobile = deviceInfo.isMobile || window.innerWidth <= 768;
            const isTablet = deviceInfo.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024);

            // Enable for mobile and tablet devices
            if (isMobile || isTablet) {
                const wasOpen = sidebar.classList.contains('mobile-open');
                sidebar.classList.toggle('mobile-open');

                // Update backdrop - show only when sidebar is open as overlay
                const backdrop = document.getElementById('sidebarBackdrop');
                if (backdrop) {
                    if (sidebar.classList.contains('mobile-open')) {
                        // Sidebar is now open as overlay
                        backdrop.classList.add('active');
                        backdrop.addEventListener('click', closeMobileSidebars);
                    } else {
                        // Sidebar is now closed/visible normally
                        // Check if any other sidebar is open as overlay
                        const hasOpenSidebar = document.querySelector('.sidebar.mobile-open');
                        if (!hasOpenSidebar) {
                            backdrop.classList.remove('active');
                            backdrop.removeEventListener('click', closeMobileSidebars);
                        }
                    }
                }

                // On mobile, close other sidebars when opening one
                if (isMobile) {
                    document.querySelectorAll('.sidebar').forEach(s => {
                        if (s !== sidebar) {
                            s.classList.remove('mobile-open');
                        }
                    });
                }
            }
        }

        function closeMobileSidebars() {
            document.querySelectorAll('.sidebar').forEach(s => {
                s.classList.remove('mobile-open');
            });
            const backdrop = document.getElementById('sidebarBackdrop');
            if (backdrop) {
                backdrop.classList.remove('active');
                backdrop.removeEventListener('click', closeMobileSidebars);
            }
        }


        // Setup back button handlers for panels
        function setupPanelBackButtons() {
            // Layers panel back button
            const layersBackBtn = document.getElementById('layersBackBtn');
            if (layersBackBtn) {
                // Remove any existing listeners to prevent duplicates
                const newLayersBtn = layersBackBtn.cloneNode(true);
                layersBackBtn.parentNode.replaceChild(newLayersBtn, layersBackBtn);

                newLayersBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    const layersSidebar = document.querySelector('.sidebar:not(.sidebar-right)');
                    if (layersSidebar) {
                        const deviceInfo = deviceDetector ? deviceDetector.getInfo() : { isMobile: false, isTablet: false };
                        const isMobile = deviceInfo.isMobile || window.innerWidth <= 768;
                        const isTablet = deviceInfo.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024);

                        if (isMobile) {
                            // On mobile, close the overlay
                            closeMobileSidebars();
                        } else if (isTablet) {
                            // On tablet, toggle sidebar visibility (hide/show)
                            toggleMobileSidebar(layersSidebar);
                        }
                    }
                });
            }

            // Visualizers panel back button
            const visualizersBackBtn = document.getElementById('visualizersBackBtn');
            if (visualizersBackBtn) {
                // Remove any existing listeners to prevent duplicates
                const newVisualizersBtn = visualizersBackBtn.cloneNode(true);
                visualizersBackBtn.parentNode.replaceChild(newVisualizersBtn, visualizersBackBtn);

                newVisualizersBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    const visualizersSidebar = document.querySelector('.sidebar-right');
                    if (visualizersSidebar) {
                        const deviceInfo = deviceDetector ? deviceDetector.getInfo() : { isMobile: false, isTablet: false };
                        const isMobile = deviceInfo.isMobile || window.innerWidth <= 768;
                        const isTablet = deviceInfo.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024);

                        if (isMobile) {
                            // On mobile, close the overlay
                            closeMobileSidebars();
                        } else if (isTablet) {
                            // On tablet, toggle sidebar visibility (hide/show)
                            toggleMobileSidebar(visualizersSidebar);
                        }
                    }
                });
            }
        }

        // Add mobile menu buttons if needed (tablets show sidebars by default, but buttons available for toggling)
        function setupMobileMenus() {
            const deviceInfo = deviceDetector ? deviceDetector.getInfo() : { isMobile: false, isTablet: false };
            const isMobile = deviceInfo.isMobile || window.innerWidth <= 768;
            const isTablet = deviceInfo.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024);

            // Show toggle buttons on mobile (required) and optionally on tablets (for overlay mode)
            if (isMobile || isTablet) {
                // Add menu toggle buttons to canvas container
                const canvasContainer = document.getElementById('canvasContainer');

                // Calculate position below toolbar
                // Top tools bar height + Toolbar height + small gap
                const topToolsBar = document.querySelector('.top-tools-bar');
                const toolbar = document.querySelector('.toolbar');
                let topOffset = 12; // Default gap

                if (topToolsBar && toolbar) {
                    const topToolsBarHeight = topToolsBar.getBoundingClientRect().height;
                    const toolbarHeight = toolbar.getBoundingClientRect().height;
                    topOffset = topToolsBarHeight + toolbarHeight + 8; // 8px gap below toolbar
                } else {
                    // Fallback calculation based on CSS values
                    // Top tools bar: clamp(48px, 6vw, 56px) + mobile offset clamp(10px, 2vw, 15px)
                    // Toolbar: clamp(48px, 6vw, 56px) to clamp(60px, 8vw, 70px)
                    const viewportWidth = window.innerWidth;
                    const topBarHeight = Math.max(48, Math.min(56, viewportWidth * 0.06)) +
                        (viewportWidth <= 768 ? Math.max(10, Math.min(15, viewportWidth * 0.02)) : 0);
                    const toolbarHeight = Math.max(48, Math.min(70, viewportWidth * 0.08));
                    topOffset = topBarHeight + toolbarHeight + 8;
                }

                // Left sidebar toggle (Layers) - REMOVED per user request
                // let leftToggle = document.getElementById('mobileMenuLeft');
                // if (leftToggle) leftToggle.remove(); 

                // Right sidebar toggle (Visualizers)

                let rightToggle = document.getElementById('mobileMenuRight');
                if (!rightToggle) {
                    rightToggle = document.createElement('button');
                    rightToggle.id = 'mobileMenuRight';
                    rightToggle.className = 'mobile-menu-toggle';
                    rightToggle.innerHTML = 'ðŸ‘ï¸';
                    rightToggle.setAttribute('aria-label', 'Toggle Visualizers Panel');
                    rightToggle.style.right = '12px';
                    rightToggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        const sidebar = document.querySelector('.sidebar-right');
                        if (sidebar) toggleMobileSidebar(sidebar);
                    });
                    canvasContainer.appendChild(rightToggle);
                }
                // Update position
                rightToggle.style.top = `${topOffset}px`;
            } else {
                // Remove mobile menu buttons on desktop
                const leftToggle = document.getElementById('mobileMenuLeft');
                const rightToggle = document.getElementById('mobileMenuRight');
                if (leftToggle) leftToggle.remove();
                if (rightToggle) rightToggle.remove();
            }
        }

        // Initialize application
        let app;
        window.addEventListener('load', () => {
            // Initialize device detector first
            deviceDetector = new DeviceDetector();

            // Setup panel back buttons
            setupPanelBackButtons();

            app = new PolygonFunApp();

            // Initialize Game System
            const game = new Game(app);
            if (typeof GameLevels !== 'undefined') {
                game.loadLevels(GameLevels);
            } else if (typeof BeginnerLevels !== 'undefined') {
                game.loadLevels(BeginnerLevels);
            }
            window.game = game;

            // Setup mobile menus
            setupMobileMenus();

            // Update mobile menus on resize and orientation change
            window.addEventListener('deviceResize', setupMobileMenus);
            window.addEventListener('resize', () => {
                // Debounce resize to avoid too many calls
                clearTimeout(window.mobileMenuResizeTimeout);
                window.mobileMenuResizeTimeout = setTimeout(() => {
                    setupMobileMenus();
                }, 100);
            });
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    setupMobileMenus();
                }, 200);
            });

            // Example: Set up telemetry callbacks
            app.setTelemetryCallbacks({
                onShapeMenuOpen: () => {
                    console.log('Shape menu opened');
                    // Track analytics event
                },
                onShapeMenuClose: () => {
                    console.log('Shape menu closed');
                    // Track analytics event
                },
                onShapeSelect: (data) => {
                    console.log('Shape selected:', data);
                    // Track shape creation: data.type, data.sides, data.polygon
                }
            });
        });

        function closeTutorial() {
            document.getElementById('tutorialOverlay').style.display = 'none';
        }

        // Example component usage for integration
        class CreatePolygonButton {
            constructor(container, options = {}) {
                this.container = container;
                this.options = {
                    onOpen: options.onOpen || (() => { }),
                    onClose: options.onClose || (() => { }),
                    onSelect: options.onSelect || (() => { }),
                    keyboard: options.keyboard || 'Ctrl+N',
                    shapes: options.shapes || [
                        { type: 'triangle', sides: 3, hint: '3 sides', icon: 'â–²' },
                        { type: 'square', sides: 4, hint: '4 equal sides', icon: 'â– ' },
                        { type: 'rectangle', sides: 4, hint: '4 sides', icon: 'â–¬' },
                        { type: 'pentagon', sides: 5, hint: '5 sides', icon: 'â¬Ÿ' },
                        { type: 'hexagon', sides: 6, hint: '6 sides', icon: 'â¬¢' },
                        { type: 'heptagon', sides: 7, hint: '7 sides (Septagon)', icon: 'â¬ ' },
                        { type: 'octagon', sides: 8, hint: '8 sides', icon: 'â¬¡' }
                    ]
                };
            }

            // Component methods for external integration
            open() { if (app) app.openShapeMenu(); }
            close() { if (app) app.closeShapeMenu(); }
            toggle() { if (app) app.toggleShapeMenu(); }
            createShape(type) {
                if (app) {
                    const option = document.querySelector(`[data-shape="${type}"]`);
                    if (option) app.selectShape(option);
                }
            }
        }

        // Geometry Utilities for Polygon Boolean Operations (Union & Split)
        // ... [Union Methods from previous implementation] ...

        // NEW: Split Method
    </script>
    <!-- Background Animation -->
    <script src="js/background-animation.js"></script>
    <!-- Audio Unlock (must load before music) -->
    <script src="js/audio-unlock.js"></script>
    <!-- Tutorial Logic -->
    <script src="js/tutorial.js"></script>
    <!-- Music Logic -->
    <script src="js/music.js"></script>
    <!-- UI Modals -->
    <script src="js/ui-modal.js"></script>
    <!-- Menu Fixes -->
    <script src="js/menu-fix.js"></script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                const protocol = window.location.protocol;
                const isSupportedOrigin = protocol === 'http:' || protocol === 'https:';

                if (!isSupportedOrigin) {
                    console.info('[PWA] Skipping service worker registration on unsupported origin:', protocol);
                    return;
                }

                navigator.serviceWorker.register('./service-worker.js')
                    .catch((error) => console.error('Service worker registration failed:', error));
            });
        }
    </script>
</body>

</html>